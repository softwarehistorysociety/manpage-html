<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Thu Sep  8 03:10:15 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>TCPDUMP</title>

</head>
<body>

<h1 align="center">TCPDUMP</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#OUTPUT FORMAT">OUTPUT FORMAT</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>
<a href="#BUGS">BUGS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">tcpdump - dump
traffic on a network</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>tcpdump</b>
[ <b>-AbdDefhHIJKlLnNOpqStuUvxX#</b> ] [ <b>-B</b>
<i>buffer_size</i> ] <br>
[ <b>-c</b> <i>count</i> ] <br>
[ <b>-C</b> <i>file_size</i> ] [ <b>-G</b>
<i>rotate_seconds</i> ] [ <b>-F</b> <i>file</i> ] <br>
[ <b>-i</b> <i>interface</i> ] [ <b>-j</b>
<i>tstamp_type</i> ] [ <b>-m</b> <i>module</i> ] [ <b>-M</b>
<i>secret</i> ] <br>
[ <b>--number</b> ] [ <b>-Q</b> <i>in|out|inout</i> ] <br>
[ <b>-r</b> <i>file</i> ] [ <b>-V</b> <i>file</i> ] [
<b>-s</b> <i>snaplen</i> ] [ <b>-T</b> <i>type</i> ] [
<b>-w</b> <i>file</i> ] <br>
[ <b>-W</b> <i>filecount</i> ] <br>
[ <b>-E</b> <i>spi@ipaddr algo:secret,...</i> ] <br>
[ <b>-y</b> <i>datalinktype</i> ] [ <b>-z</b>
<i>postrotate-command</i> ] [ <b>-Z</b> <i>user</i> ] <br>
[ <b>--time-stamp-precision=</b><i>tstamp_precision</i> ]
<br>
[ <b>--immediate-mode</b> ] [ <b>--version</b> ] <br>
[ <i>expression</i> ]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>Tcpdump</i>
prints out a description of the contents of packets on a
network interface that match the boolean <i>expression</i>;
the description is preceded by a time stamp, printed, by
default, as hours, minutes, seconds, and fractions of a
second since midnight. It can also be run with the <b>-w</b>
flag, which causes it to save the packet data to a file for
later analysis, and/or with the <b>-r</b> flag, which causes
it to read from a saved packet file rather than to read
packets from a network interface. It can also be run with
the <b>-V</b> flag, which causes it to read a list of saved
packet files. In all cases, only packets that match
<i>expression</i> will be processed by <i>tcpdump</i>.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Tcpdump</i>
will, if not run with the <b>-c</b> flag, continue capturing
packets until it is interrupted by a SIGINT signal
(generated, for example, by typing your interrupt character,
typically control-C) or a SIGTERM signal (typically
generated with the <b>kill</b>(1) command); if run with the
<b>-c</b> flag, it will capture packets until it is
interrupted by a SIGINT or SIGTERM signal or the specified
number of packets have been processed.</p>

<p style="margin-left:11%; margin-top: 1em">When
<i>tcpdump</i> finishes capturing packets, it will report
counts of:</p>

<p style="margin-left:22%; margin-top: 1em">packets
&rsquo;&rsquo;captured&rsquo;&rsquo; (this is the number of
packets that <i>tcpdump</i> has received and processed);</p>

<p style="margin-left:22%; margin-top: 1em">packets
&rsquo;&rsquo;received by filter&rsquo;&rsquo; (the meaning
of this depends on the OS on which you&rsquo;re running
<i>tcpdump</i>, and possibly on the way the OS was
configured - if a filter was specified on the command line,
on some OSes it counts packets regardless of whether they
were matched by the filter expression and, even if they were
matched by the filter expression, regardless of whether
<i>tcpdump</i> has read and processed them yet, on other
OSes it counts only packets that were matched by the filter
expression regardless of whether <i>tcpdump</i> has read and
processed them yet, and on other OSes it counts only packets
that were matched by the filter expression and were
processed by <i>tcpdump</i>);</p>

<p style="margin-left:22%; margin-top: 1em">packets
&rsquo;&rsquo;dropped by kernel&rsquo;&rsquo; (this is the
number of packets that were dropped, due to a lack of buffer
space, by the packet capture mechanism in the OS on which
<i>tcpdump</i> is running, if the OS reports that
information to applications; if not, it will be reported as
0).</p>

<p style="margin-left:11%; margin-top: 1em">On platforms
that support the SIGINFO signal, such as most BSDs
(including Mac OS X) and Digital/Tru64 UNIX, it will report
those counts when it receives a SIGINFO signal (generated,
for example, by typing your
&rsquo;&rsquo;status&rsquo;&rsquo; character, typically
control-T, although on some platforms, such as Mac OS X, the
&rsquo;&rsquo;status&rsquo;&rsquo; character is not set by
default, so you must set it with <b>stty</b>(1) in order to
use it) and will continue capturing packets. On platforms
that do not support the SIGINFO signal, the same can be
achieved by using the SIGUSR1 signal.</p>

<p style="margin-left:11%; margin-top: 1em">Reading packets
from a network interface may require that you have special
privileges; see the <b>pcap (3PCAP)</b> man page for
details. Reading a saved packet file doesn&rsquo;t require
special privileges.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>-A</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Print each packet (minus its
link level header) in ASCII. Handy for capturing web
pages.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-b</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Print the AS number in BGP packets in ASDOT notation
rather than ASPLAIN notation.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-B</b> <i>buffer_size</i>
<b><br>
--buffer-size=</b><i>buffer_size</i></p>

<p style="margin-left:22%;">Set the operating system
capture buffer size to <i>buffer_size</i>, in units of KiB
(1024 bytes).</p>

<p style="margin-left:11%;"><b>-c</b> <i>count</i></p>

<p style="margin-left:22%;">Exit after receiving
<i>count</i> packets.</p>

<p style="margin-left:11%;"><b>-C</b> <i>file_size</i></p>

<p style="margin-left:22%;">Before writing a raw packet to
a savefile, check whether the file is currently larger than
<i>file_size</i> and, if so, close the current savefile and
open a new one. Savefiles after the first savefile will have
the name specified with the <b>-w</b> flag, with a number
after it, starting at 1 and continuing upward. The units of
<i>file_size</i> are millions of bytes (1,000,000 bytes, not
1,048,576 bytes).</p>

<p style="margin-left:22%; margin-top: 1em">Note that when
used with <b>-Z</b> option (enabled by default), privileges
are dropped before opening first savefile.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>-d</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Dump the compiled packet-matching code in a human
readable form to standard output and stop.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>-dd</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Dump packet-matching code as a <b>C</b> program
fragment.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>-ddd</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Dump packet-matching code as decimal numbers (preceded
with a count).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>-D</b></p></td>
<td width="5%"></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>--list-interfaces</b></p>

<p style="margin-left:22%;">Print the list of the network
interfaces available on the system and on which
<i>tcpdump</i> can capture packets. For each network
interface, a number and an interface name, possibly followed
by a text description of the interface, is printed. The
interface name or the number can be supplied to the
<b>-i</b> flag to specify an interface on which to
capture.</p>

<p style="margin-left:22%; margin-top: 1em">This can be
useful on systems that don&rsquo;t have a command to list
them (e.g., Windows systems, or UNIX systems lacking
<b>ifconfig -a</b>); the number can be useful on Windows
2000 and later systems, where the interface name is a
somewhat complex string.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>-D</b>
flag will not be supported if <i>tcpdump</i> was built with
an older version of <i>libpcap</i> that lacks the
<b>pcap_findalldevs()</b> function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-e</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Print the link-level header on each dump line. This can
be used, for example, to print MAC layer addresses for
protocols such as Ethernet and IEEE 802.11.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-E</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Use <i>spi@ipaddr algo:secret</i> for decrypting IPsec
ESP packets that are addressed to <i>addr</i> and contain
Security Parameter Index value <i>spi</i>. This combination
may be repeated with comma or newline separation.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Note that
setting the secret for IPv4 ESP packets is supported at this
time.</p>

<p style="margin-left:22%; margin-top: 1em">Algorithms may
be <b>des-cbc</b>, <b>3des-cbc</b>, <b>blowfish-cbc</b>,
<b>rc3-cbc</b>, <b>cast128-cbc</b>, or <b>none</b>. The
default is <b>des-cbc</b>. The ability to decrypt packets is
only present if <i>tcpdump</i> was compiled with
cryptography enabled.</p>

<p style="margin-left:22%; margin-top: 1em"><i>secret</i>
is the ASCII text for ESP secret key. If preceded by 0x,
then a hex value will be read.</p>

<p style="margin-left:22%; margin-top: 1em">The option
assumes RFC2406 ESP, not RFC1827 ESP. The option is only for
debugging purposes, and the use of this option with a true
&rsquo;secret&rsquo; key is discouraged. By presenting IPsec
secret key onto command line you make it visible to others,
via <i>ps</i>(1) and other occasions.</p>

<p style="margin-left:22%; margin-top: 1em">In addition to
the above syntax, the syntax <i>file name</i> may be used to
have tcpdump read the provided file in. The file is opened
upon receiving the first ESP packet, so any special
permissions that tcpdump may have been given should already
have been given up.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>-f</b></p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">Print &rsquo;foreign&rsquo; IPv4
addresses numerically rather than symbolically (this option
is intended to get around serious brain damage in
Sun&rsquo;s NIS server &mdash; usually it hangs forever
translating non-local internet numbers).</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">The test for
&rsquo;foreign&rsquo; IPv4 addresses is done using the IPv4
address and netmask of the interface on which capture is
being done. If that address or netmask are not available,
available, either because the interface on which capture is
being done has no address or netmask or because the capture
is being done on the Linux &quot;any&quot; interface, which
can capture on more than one interface, this option will not
work correctly.</p>

<p style="margin-left:11%;"><b>-F</b> <i>file</i></p>

<p style="margin-left:22%;">Use <i>file</i> as input for
the filter expression. An additional expression given on the
command line is ignored.</p>

<p style="margin-left:11%;"><b>-G</b>
<i>rotate_seconds</i></p>

<p style="margin-left:22%;">If specified, rotates the dump
file specified with the <b>-w</b> option every
<i>rotate_seconds</i> seconds. Savefiles will have the name
specified by <b>-w</b> which should include a time format as
defined by <b>strftime</b>(3). If no time format is
specified, each new file will overwrite the previous.</p>

<p style="margin-left:22%; margin-top: 1em">If used in
conjunction with the <b>-C</b> option, filenames will take
the form of &rsquo;<i>file</i>&lt;count&gt;&rsquo;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>-h</b></p></td>
<td width="2%"></td>
<td width="78%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>--help</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print the tcpdump and libpcap version strings, print a
usage message, and exit.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>--version</b></p>

<p style="margin-left:22%;">Print the tcpdump and libpcap
version strings and exit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-H</b></p></td>
<td width="8%"></td>
<td width="69%">


<p>Attempt to detect 802.11s draft mesh headers.</p></td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>-i</b> <i>interface</i>
<b><br>
--interface=</b><i>interface</i></p>

<p style="margin-left:22%;">Listen on <i>interface</i>. If
unspecified, <i>tcpdump</i> searches the system interface
list for the lowest numbered, configured up interface
(excluding loopback), which may turn out to be, for example,
&rsquo;&rsquo;eth0&rsquo;&rsquo;.</p>

<p style="margin-left:22%; margin-top: 1em">On Linux
systems with 2.2 or later kernels, an <i>interface</i>
argument of &rsquo;&rsquo;any&rsquo;&rsquo; can be used to
capture packets from all interfaces. Note that captures on
the &rsquo;&rsquo;any&rsquo;&rsquo; device will not be done
in promiscuous mode.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>-D</b> flag is supported, an interface number as printed
by that flag can be used as the <i>interface</i> argument,
if no interface on the system has that number as a name.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-I</b></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>--monitor-mode</b></p>

<p style="margin-left:22%;">Put the interface in
&quot;monitor mode&quot;; this is supported only on IEEE
802.11 Wi-Fi interfaces, and supported only on some
operating systems.</p>

<p style="margin-left:22%; margin-top: 1em">Note that in
monitor mode the adapter might disassociate from the network
with which it&rsquo;s associated, so that you will not be
able to use any wireless networks with that adapter. This
could prevent accessing files on a network server, or
resolving host names or network addresses, if you are
capturing in monitor mode and are not connected to another
network with another adapter.</p>

<p style="margin-left:22%; margin-top: 1em">This flag will
affect the output of the <b>-L</b> flag. If <b>-I</b>
isn&rsquo;t specified, only those link-layer types available
when not in monitor mode will be shown; if <b>-I</b> is
specified, only those link-layer types available when in
monitor mode will be shown.</p>

<p style="margin-left:11%;"><b>--immediate-mode</b></p>

<p style="margin-left:22%;">Capture in &quot;immediate
mode&quot;. In this mode, packets are delivered to tcpdump
as soon as they arrive, rather than being buffered for
efficiency. This is the default when printing packets rather
than saving packets to a
&rsquo;&rsquo;savefile&rsquo;&rsquo; if the packets are
being printed to a terminal rather than to a file or
pipe.</p>

<p style="margin-left:11%;"><b>-j</b> <i>tstamp_type</i>
<b><br>
--time-stamp-type=</b><i>tstamp_type</i></p>

<p style="margin-left:22%;">Set the time stamp type for the
capture to <i>tstamp_type</i>. The names to use for the time
stamp types are given in <b>pcap-tstamp</b>(7); not all the
types listed there will necessarily be valid for any given
interface.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-J</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>--list-time-stamp-types</b></p>

<p style="margin-left:22%;">List the supported time stamp
types for the interface and exit. If the time stamp type
cannot be set for the interface, no time stamp types are
listed.</p>


<p style="margin-left:11%;"><b>--time-stamp-precision=</b><i>tstamp_precision</i></p>

<p style="margin-left:22%;">When capturing, set the time
stamp precision for the capture to <i>tstamp_precision</i>.
Note that availability of high precision time stamps
(nanoseconds) and their actual accuracy is platform and
hardware dependent. Also note that when writing captures
made with nanosecond accuracy to a savefile, the time stamps
are written with nanosecond resolution, and the file is
written with a different magic number, to indicate that the
time stamps are in seconds and nanoseconds; not all programs
that read pcap savefiles will be able to read those
captures.</p>

<p style="margin-left:11%; margin-top: 1em">When reading a
savefile, convert time stamps to the precision specified by
<i>timestamp_precision</i>, and display them with that
resolution. If the precision specified is less than the
precision of time stamps in the file, the conversion will
lose precision.</p>

<p style="margin-left:11%; margin-top: 1em">The supported
values for <i>timestamp_precision</i> are <b>micro</b> for
microsecond resolution and <b>nano</b> for nanosecond
resolution. The default is microsecond resolution.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-K</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>--dont-verify-checksums</b></p>

<p style="margin-left:22%;">Don&rsquo;t attempt to verify
IP, TCP, or UDP checksums. This is useful for interfaces
that perform some or all of those checksum calculation in
hardware; otherwise, all outgoing TCP checksums will be
flagged as bad.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-l</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Make stdout line buffered. Useful if you want to see the
data while capturing it. E.g.,</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em"><b>tcpdump -l |
tee dat</b></p>

<p style="margin-left:22%; margin-top: 1em">or</p>

<p style="margin-left:32%; margin-top: 1em"><b>tcpdump -l
&gt; dat &amp; tail -f dat</b></p>

<p style="margin-left:22%; margin-top: 1em">Note that on
Windows,&rsquo;&rsquo;line buffered&rsquo;&rsquo; means
&rsquo;&rsquo;unbuffered&rsquo;&rsquo;, so that WinDump will
write each character individually if <b>-l</b> is
specified.</p>

<p style="margin-left:22%; margin-top: 1em"><b>-U</b> is
similar to <b>-l</b> in its behavior, but it will cause
output to be &rsquo;&rsquo;packet-buffered&rsquo;&rsquo;, so
that the output is written to stdout at the end of each
packet rather than at the end of each line; this is buffered
on all platforms, including Windows.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em"><b>-L</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>--list-data-link-types</b></p>

<p style="margin-left:22%;">List the known data link types
for the interface, in the specified mode, and exit. The list
of known data link types may be dependent on the specified
mode; for example, on some platforms, a Wi-Fi interface
might support one set of data link types when not in monitor
mode (for example, it might support only fake Ethernet
headers, or might support 802.11 headers but not support
802.11 headers with radio information) and another set of
data link types when in monitor mode (for example, it might
support 802.11 headers, or 802.11 headers with radio
information, only in monitor mode).</p>

<p style="margin-left:11%;"><b>-m</b> <i>module</i></p>

<p style="margin-left:22%;">Load SMI MIB module definitions
from file <i>module</i>. This option can be used several
times to load several MIB modules into <i>tcpdump</i>.</p>

<p style="margin-left:11%;"><b>-M</b> <i>secret</i></p>

<p style="margin-left:22%;">Use <i>secret</i> as a shared
secret for validating the digests found in TCP segments with
the TCP-MD5 option (RFC 2385), if present.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-n</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Don&rsquo;t convert addresses (i.e., host addresses,
port numbers, etc.) to names.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-N</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Don&rsquo;t print domain name qualification of host
names. E.g., if you give this flag then <i>tcpdump</i> will
print &rsquo;&rsquo;nic&rsquo;&rsquo; instead of
&rsquo;&rsquo;nic.ddn.mil&rsquo;&rsquo;.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-#</b></p></td>
<td width="8%"></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>--number</b></p>

<p style="margin-left:22%;">Print an optional packet number
at the beginning of the line.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-O</b></p></td>
<td width="86%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>--no-optimize</b></p>

<p style="margin-left:22%;">Do not run the packet-matching
code optimizer. This is useful only if you suspect a bug in
the optimizer.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-p</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>--no-promiscuous-mode</b></p>

<p style="margin-left:22%;"><i>Don&rsquo;t</i> put the
interface into promiscuous mode. Note that the interface
might be in promiscuous mode for some other reason; hence,
&rsquo;-p&rsquo; cannot be used as an abbreviation for
&rsquo;ether host {local-hw-addr} or ether
broadcast&rsquo;.</p>

<p style="margin-left:11%;"><b>-Q</b> <i>direction</i>
<b><br>
--direction=</b><i>direction</i></p>

<p style="margin-left:22%;">Choose send/receive direction
<i>direction</i> for which packets should be captured.
Possible values are &rsquo;in&rsquo;, &rsquo;out&rsquo; and
&rsquo;inout&rsquo;. Not available on all platforms.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-q</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Quick (quiet?) output. Print less protocol information
so output lines are shorter.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-r</b> <i>file</i></p>

<p style="margin-left:22%;">Read packets from <i>file</i>
(which was created with the <b>-w</b> option or by other
tools that write pcap or pcap-ng files). Standard input is
used if <i>file</i> is &rsquo;&rsquo;-&rsquo;&rsquo;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-S</b></p></td>
<td width="86%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>--absolute-tcp-sequence-numbers</b></p>

<p style="margin-left:22%;">Print absolute, rather than
relative, TCP sequence numbers.</p>

<p style="margin-left:11%;"><b>-s</b> <i>snaplen</i>
<b><br>
--snapshot-length=</b><i>snaplen</i></p>

<p style="margin-left:22%;">Snarf <i>snaplen</i> bytes of
data from each packet rather than the default of 262144
bytes. Packets truncated because of a limited snapshot are
indicated in the output with
&rsquo;&rsquo;[|<i>proto</i>]&rsquo;&rsquo;, where
<i>proto</i> is the name of the protocol level at which the
truncation has occurred. Note that taking larger snapshots
both increases the amount of time it takes to process
packets and, effectively, decreases the amount of packet
buffering. This may cause packets to be lost. You should
limit <i>snaplen</i> to the smallest number that will
capture the protocol information you&rsquo;re interested in.
Setting <i>snaplen</i> to 0 sets it to the default of
262144, for backwards compatibility with recent older
versions of <i>tcpdump</i>.</p>

<p style="margin-left:11%;"><b>-T</b> <i>type</i></p>

<p style="margin-left:22%;">Force packets selected by
&quot;<i>expression</i>&quot; to be interpreted the
specified <i>type</i>. Currently known types are <b>aodv</b>
(Ad-hoc On-demand Distance Vector protocol), <b>carp</b>
(Common Address Redundancy Protocol), <b>cnfp</b> (Cisco
NetFlow protocol), <b>lmp</b> (Link Management Protocol),
<b>pgm</b> (Pragmatic General Multicast), <b>pgm_zmtp1</b>
(ZMTP/1.0 inside PGM/EPGM), <b>resp</b> (REdis Serialization
Protocol), <b>radius</b> (RADIUS), <b>rpc</b> (Remote
Procedure Call), <b>rtp</b> (Real-Time Applications
protocol), <b>rtcp</b> (Real-Time Applications control
protocol), <b>snmp</b> (Simple Network Management Protocol),
<b>tftp</b> (Trivial File Transfer Protocol), <b>vat</b>
(Visual Audio Tool), <b>wb</b> (distributed White Board),
<b>zmtp1</b> (ZeroMQ Message Transport Protocol 1.0) and
<b>vxlan</b> (Virtual eXtensible Local Area Network).</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
<b>pgm</b> type above affects UDP interpretation only, the
native PGM is always recognised as IP protocol 113
regardless. UDP-encapsulated PGM is often called
&quot;EPGM&quot; or &quot;PGM/UDP&quot;.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
<b>pgm_zmtp1</b> type above affects interpretation of both
native PGM and UDP at once. During the native PGM decoding
the application data of an ODATA/RDATA packet would be
decoded as a ZeroMQ datagram with ZMTP/1.0 frames. During
the UDP decoding in addition to that any UDP packet would be
treated as an encapsulated PGM packet.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>-t</b></p></td>
<td width="2%"></td>
<td width="78%">


<p><i>Don&rsquo;t</i> print a timestamp on each dump
line.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>-tt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print the timestamp, as seconds since January 1, 1970,
00:00:00, UTC, and fractions of a second since that time, on
each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>-ttt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print a delta (micro-second resolution) between current
and previous line on each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>-tttt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print a timestamp, as hours, minutes, seconds, and
fractions of a second since midnight, preceded by the date,
on each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>-ttttt</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print a delta (micro-second resolution) between current
and first line on each dump line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>-u</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>Print undecoded NFS handles.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>-U</b></p></td>
<td width="2%"></td>
<td width="78%">
</td></tr>
</table>

<p style="margin-left:11%;"><b>--packet-buffered</b></p>

<p style="margin-left:22%;">If the <b>-w</b> option is not
specified, make the printed packet output
&rsquo;&rsquo;packet-buffered&rsquo;&rsquo;; i.e., as the
description of the contents of each packet is printed, it
will be written to the standard output, rather than, when
not writing to a terminal, being written only when the
output buffer fills.</p>

<p style="margin-left:22%; margin-top: 1em">If the
<b>-w</b> option is specified, make the saved raw packet
output &rsquo;&rsquo;packet-buffered&rsquo;&rsquo;; i.e., as
each packet is saved, it will be written to the output file,
rather than being written only when the output buffer
fills.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>-U</b>
flag will not be supported if <i>tcpdump</i> was built with
an older version of <i>libpcap</i> that lacks the
<b>pcap_dump_flush()</b> function.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-v</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>When parsing and printing, produce (slightly more)
verbose output. For example, the time to live,
identification, total length and options in an IP packet are
printed. Also enables additional packet integrity checks
such as verifying the IP and ICMP header checksum.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">When writing to
a file with the <b>-w</b> option, report, every 10 seconds,
the number of packets captured.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p style="margin-top: 1em"><b>-vv</b></p></td>
<td width="5%"></td>
<td width="78%">


<p style="margin-top: 1em">Even more verbose output. For
example, additional fields are printed from NFS reply
packets, and SMB packets are fully decoded.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p><b>-vvv</b></p></td>
<td width="5%"></td>
<td width="78%">


<p>Even more verbose output. For example, telnet <b>SB</b>
... <b>SE</b> options are printed in full. With <b>-X</b>
Telnet options are printed in hex as well.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-V</b> <i>file</i></p>

<p style="margin-left:22%;">Read a list of filenames from
<i>file</i>. Standard input is used if <i>file</i> is
&rsquo;&rsquo;-&rsquo;&rsquo;.</p>

<p style="margin-left:11%;"><b>-w</b> <i>file</i></p>

<p style="margin-left:22%;">Write the raw packets to
<i>file</i> rather than parsing and printing them out. They
can later be printed with the -r option. Standard output is
used if <i>file</i> is &rsquo;&rsquo;-&rsquo;&rsquo;.</p>

<p style="margin-left:22%; margin-top: 1em">This output
will be buffered if written to a file or pipe, so a program
reading from the file or pipe may not see packets for an
arbitrary amount of time after they are received. Use the
<b>-U</b> flag to cause packets to be written as soon as
they are received.</p>

<p style="margin-left:22%; margin-top: 1em">The MIME type
<i>application/vnd.tcpdump.pcap</i> has been registered with
IANA for <i>pcap</i> files. The filename extension
<i>.pcap</i> appears to be the most commonly used along with
<i>.cap</i> and <i>.dmp</i>. <i>Tcpdump</i> itself
doesn&rsquo;t check the extension when reading capture files
and doesn&rsquo;t add an extension when writing them (it
uses magic numbers in the file header instead). However,
many operating systems and applications will use the
extension if it is present and adding one (e.g. .pcap) is
recommended.</p>

<p style="margin-left:22%; margin-top: 1em">See
<b>pcap-savefile</b>(5) for a description of the file
format.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p><b>-W</b></p></td>
<td width="8%"></td>
<td width="78%">


<p>Used in conjunction with the <b>-C</b> option, this will
limit the number of files created to the specified number,
and begin overwriting files from the beginning, thus
creating a &rsquo;rotating&rsquo; buffer. In addition, it
will name the files with enough leading 0s to support the
maximum number of files, allowing them to sort
correctly.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Used in
conjunction with the <b>-G</b> option, this will limit the
number of rotated dump files that get created, exiting with
status 0 when reaching the limit. If used with <b>-C</b> as
well, the behavior will result in cyclical files per
timeslice.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>-x</b></p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">When parsing and printing, in
addition to printing the headers of each packet, print the
data of each packet (minus its link level header) in hex.
The smaller of the entire packet or <i>snaplen</i> bytes
will be printed. Note that this is the entire link-layer
packet, so for link layers that pad (e.g. Ethernet), the
padding bytes will also be printed when the higher layer
packet is shorter than the required padding.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>-xx</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>When parsing and printing, in addition to printing the
headers of each packet, print the data of each packet,
<i>including</i> its link level header, in hex.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>-X</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>When parsing and printing, in addition to printing the
headers of each packet, print the data of each packet (minus
its link level header) in hex and ASCII. This is very handy
for analysing new protocols.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>-XX</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>When parsing and printing, in addition to printing the
headers of each packet, print the data of each packet,
<i>including</i> its link level header, in hex and
ASCII.</p> </td></tr>
</table>

<p style="margin-left:11%;"><b>-y</b> <i>datalinktype</i>
<b><br>
--linktype=</b><i>datalinktype</i></p>

<p style="margin-left:22%;">Set the data link type to use
while capturing packets to <i>datalinktype</i>.</p>

<p style="margin-left:11%;"><b>-z</b>
<i>postrotate-command</i></p>

<p style="margin-left:22%;">Used in conjunction with the
<b>-C</b> or <b>-G</b> options, this will make
<i>tcpdump</i> run &quot; <i>postrotate-command file</i>
&quot; where <i>file</i> is the savefile being closed after
each rotation. For example, specifying <b>-z gzip</b> or
<b>-z bzip2</b> will compress each savefile using gzip or
bzip2.</p>

<p style="margin-left:22%; margin-top: 1em">Note that
tcpdump will run the command in parallel to the capture,
using the lowest priority so that this doesn&rsquo;t disturb
the capture process.</p>

<p style="margin-left:22%; margin-top: 1em">And in case you
would like to use a command that itself takes flags or
different arguments, you can always write a shell script
that will take the savefile name as the only argument, make
the flags &amp; arguments arrangements and execute the
command that you want.</p>

<p style="margin-left:11%;"><b>-Z</b> <i>user</i> <b><br>
--relinquish-privileges=</b><i>user</i></p>

<p style="margin-left:22%;">If <i>tcpdump</i> is running as
root, after opening the capture device or input savefile,
change the user ID to <i>user</i> and the group ID to the
primary group of <i>user</i>.</p>

<p style="margin-left:22%; margin-top: 1em">This behavior
is enabled by default (<b>-Z tcpdump</b>), and can be
disabled by <b>-Z root</b>.</p>

<p style="margin-left:11%;"><i>expression</i></p>

<p style="margin-left:22%;">selects which packets will be
dumped. If no <i>expression</i> is given, all packets on the
net will be dumped. Otherwise, only packets for which
<i>expression</i> is &rsquo;true&rsquo; will be dumped.</p>

<p style="margin-left:22%; margin-top: 1em">For the
<i>expression</i> syntax, see <b>pcap-filter</b>(7).</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>expression</i> argument can be passed to <i>tcpdump</i>
as either a single Shell argument, or as multiple Shell
arguments, whichever is more convenient. Generally, if the
expression contains Shell metacharacters, such as
backslashes used to escape protocol names, it is easier to
pass it as a single, quoted argument rather than to escape
the Shell metacharacters. Multiple arguments are
concatenated with spaces before being parsed.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To print all
packets arriving at or departing from <i>sundown</i>:</p>

<p style="margin-left:22%;"><b>tcpdump host sundown</b></p>

<p style="margin-left:11%; margin-top: 1em">To print
traffic between <i>helios</i> and either <i>hot</i> or
<i>ace</i>:</p>

<p style="margin-left:22%;"><b>tcpdump host helios and \(
hot or ace \)</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all IP
packets between <i>ace</i> and any host except
<i>helios</i>:</p>

<p style="margin-left:22%;"><b>tcpdump ip host ace and not
helios</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all
traffic between local hosts and hosts at Berkeley:</p>

<p style="margin-left:22%;"><b>tcpdump net
ucb-ether</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all
ftp traffic through internet gateway <i>snup</i>: (note that
the expression is quoted to prevent the shell from
(mis-)interpreting the parentheses):</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;gateway snup
and (port ftp or ftp-data)&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print
traffic neither sourced from nor destined for local hosts
(if you gateway to one other net, this stuff should never
make it onto your local net).</p>

<p style="margin-left:22%;"><b>tcpdump ip and not net</b>
<i>localnet</i></p>

<p style="margin-left:11%; margin-top: 1em">To print the
start and end packets (the SYN and FIN packets) of each TCP
conversation that involves a non-local host.</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;tcp[tcpflags]
&amp; (tcp-syn|tcp-fin) != 0 and not src and dst net</b>
<i>localnet</i><b>&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all
IPv4 HTTP packets to and from port 80, i.e. print only
packets that contain data, not, for example, SYN and FIN
packets and ACK-only packets. (IPv6 is left as an exercise
for the reader.)</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;tcp port 80
and (((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) -
((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print IP
packets longer than 576 bytes sent through gateway
<i>snup</i>:</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;gateway snup
and ip[2:2] &gt; 576&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print IP
broadcast or multicast packets that were <i>not</i> sent via
Ethernet broadcast or multicast:</p>

<p style="margin-left:22%;"><b>tcpdump &rsquo;ether[0]
&amp; 1 = 0 and ip[16] &gt;= 224&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">To print all
ICMP packets that are not echo requests/replies (i.e., not
ping packets):</p>

<p style="margin-left:22%;"><b>tcpdump
&rsquo;icmp[icmptype] != icmp-echo and icmp[icmptype] !=
icmp-echoreply&rsquo;</b></p>

<h2>OUTPUT FORMAT
<a name="OUTPUT FORMAT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The output of
<i>tcpdump</i> is protocol dependent. The following gives a
brief description and examples of most of the formats.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Timestamps</b></p>

<p style="margin-left:11%; margin-top: 1em">By default, all
output lines are preceded by a timestamp. The timestamp is
the current clock time in the form</p>

<p style="margin-left:22%;"><i>hh:mm:ss.frac</i></p>

<p style="margin-left:11%;">and is as accurate as the
kernel&rsquo;s clock. The timestamp reflects the time the
kernel applied a time stamp to the packet. No attempt is
made to account for the time lag between when the network
interface finished receiving the packet from the network and
when the kernel applied a time stamp to the packet; that
time lag could include a delay between the time when the
network interface finished receiving a packet from the
network and the time when an interrupt was delivered to the
kernel to get it to read the packet and a delay between the
time when the kernel serviced the &rsquo;new packet&rsquo;
interrupt and the time when it applied a time stamp to the
packet.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Link Level
Headers</b></p>

<p style="margin-left:11%; margin-top: 1em">If the
&rsquo;-e&rsquo; option is given, the link level header is
printed out. On Ethernets, the source and destination
addresses, protocol, and packet length are printed.</p>

<p style="margin-left:11%; margin-top: 1em">On FDDI
networks, the &rsquo;-e&rsquo; option causes <i>tcpdump</i>
to print the &rsquo;frame control&rsquo; field, the source
and destination addresses, and the packet length. (The
&rsquo;frame control&rsquo; field governs the interpretation
of the rest of the packet. Normal packets (such as those
containing IP datagrams) are &rsquo;async&rsquo; packets,
with a priority value between 0 and 7; for example,
&rsquo;<b>async4</b>&rsquo;. Such packets are assumed to
contain an 802.2 Logical Link Control (LLC) packet; the LLC
header is printed if it is <i>not</i> an ISO datagram or a
so-called SNAP packet.</p>

<p style="margin-left:11%; margin-top: 1em">On Token Ring
networks, the &rsquo;-e&rsquo; option causes <i>tcpdump</i>
to print the &rsquo;access control&rsquo; and &rsquo;frame
control&rsquo; fields, the source and destination addresses,
and the packet length. As on FDDI networks, packets are
assumed to contain an LLC packet. Regardless of whether the
&rsquo;-e&rsquo; option is specified or not, the source
routing information is printed for source-routed
packets.</p>

<p style="margin-left:11%; margin-top: 1em">On 802.11
networks, the &rsquo;-e&rsquo; option causes <i>tcpdump</i>
to print the &rsquo;frame control&rsquo; fields, all of the
addresses in the 802.11 header, and the packet length. As on
FDDI networks, packets are assumed to contain an LLC
packet.</p>

<p style="margin-left:11%; margin-top: 1em"><i>(N.B.: The
following description assumes familiarity with the SLIP
compression algorithm described in RFC-1144.)</i></p>

<p style="margin-left:11%; margin-top: 1em">On SLIP links,
a direction indicator (&rsquo;&rsquo;I&rsquo;&rsquo; for
inbound, &rsquo;&rsquo;O&rsquo;&rsquo; for outbound), packet
type, and compression information are printed out. The
packet type is printed first. The three types are <i>ip</i>,
<i>utcp</i>, and <i>ctcp</i>. No further link information is
printed for <i>ip</i> packets. For TCP packets, the
connection identifier is printed following the type. If the
packet is compressed, its encoded header is printed out. The
special cases are printed out as <b>*S+</b><i>n</i> and
<b>*SA+</b><i>n</i>, where <i>n</i> is the amount by which
the sequence number (or sequence number and ack) has
changed. If it is not a special case, zero or more changes
are printed. A change is indicated by U (urgent pointer), W
(window), A (ack), S (sequence number), and I (packet ID),
followed by a delta (+n or -n), or a new value (=n).
Finally, the amount of data in the packet and compressed
header length are printed.</p>

<p style="margin-left:11%; margin-top: 1em">For example,
the following line shows an outbound compressed TCP packet,
with an implicit connection identifier; the ack has changed
by 6, the sequence number by 49, and the packet ID by 6;
there are 3 bytes of data and 6 bytes of compressed
header:</p>

<p style="margin-left:22%;"><b>O ctcp * A+6 S+49 I+6 3
(6)</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>ARP/RARP
Packets</b></p>

<p style="margin-left:11%; margin-top: 1em">Arp/rarp output
shows the type of request and its arguments. The format is
intended to be self explanatory. Here is a short sample
taken from the start of an &rsquo;rlogin&rsquo; from host
<i>rtsg</i> to host <i>csam</i>:</p>

<p style="margin-left:22%;">arp who-has csam tell rtsg <br>
arp reply csam is-at CSAM</p>

<p style="margin-left:11%;">The first line says that rtsg
sent an arp packet asking for the Ethernet address of
internet host csam. Csam replies with its Ethernet address
(in this example, Ethernet addresses are in caps and
internet addresses in lower case).</p>

<p style="margin-left:11%; margin-top: 1em">This would look
less redundant if we had done <i>tcpdump -n</i>:</p>

<p style="margin-left:22%;">arp who-has 128.3.254.6 tell
128.3.254.68 <br>
arp reply 128.3.254.6 is-at 02:07:01:00:01:c4</p>

<p style="margin-left:11%; margin-top: 1em">If we had done
<i>tcpdump -e</i>, the fact that the first packet is
broadcast and the second is point-to-point would be
visible:</p>

<p style="margin-left:22%;">RTSG Broadcast 0806 64: arp
who-has csam tell rtsg <br>
CSAM RTSG 0806 64: arp reply csam is-at CSAM</p>

<p style="margin-left:11%;">For the first packet this says
the Ethernet source address is RTSG, the destination is the
Ethernet broadcast address, the type field contained hex
0806 (type ETHER_ARP) and the total length was 64 bytes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>IPv4
Packets</b></p>

<p style="margin-left:11%; margin-top: 1em">If the
link-layer header is not being printed, for IPv4 packets,
<b>IP</b> is printed after the time stamp.</p>

<p style="margin-left:11%; margin-top: 1em">If the
<b>-v</b> flag is specified, information from the IPv4
header is shown in parentheses after the <b>IP</b> or the
link-layer header. The general format of this information
is:</p>

<p style="margin-left:22%;">tos <i>tos</i>, ttl <i>ttl</i>,
id <i>id</i>, offset <i>offset</i>, flags [<i>flags</i>],
proto <i>proto</i>, length <i>length</i>, options
(<i>options</i>)</p>

<p style="margin-left:11%;"><i>tos</i> is the type of
service field; if the ECN bits are non-zero, those are
reported as <b>ECT(1)</b>, <b>ECT(0)</b>, or <b>CE</b>.
<i>ttl</i> is the time-to-live; it is not reported if it is
zero. <i>id</i> is the IP identification field.
<i>offset</i> is the fragment offset field; it is printed
whether this is part of a fragmented datagram or not.
<i>flags</i> are the MF and DF flags; <b>+</b> is reported
if MF is set, and <b>DFP is reported if F is set. If neither
are set, . is reported.</b> <i>proto</i> <b>is the protocol
ID field.</b> <i>length</i> <b>is the total length
field.</b> <i>options</i> <b>are the IP options, if
any.</b></p>

<p style="margin-left:11%; margin-top: 1em">Next, for TCP
and UDP packets, the source and destination IP addresses and
TCP or UDP ports, with a dot between each IP address and its
corresponding port, will be printed, with a &gt; separating
the source and destination. For other protocols, the
addresses will be printed, with a &gt; separating the source
and destination. Higher level protocol information, if any,
will be printed after that.</p>

<p style="margin-left:11%; margin-top: 1em">For fragmented
IP datagrams, the first fragment contains the higher level
protocol header; fragments after the first contain no higher
level protocol header. Fragmentation information will be
printed only with the <b>-v</b> flag, in the IP header
information, as described above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>TCP
Packets</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>(N.B.:The
following description assumes familiarity with the TCP
protocol described in RFC-793. If you are not familiar with
the protocol, this description will not be of much use to
you.)</i></p>

<p style="margin-left:11%; margin-top: 1em">The general
format of a TCP protocol line is:</p>

<p style="margin-left:22%;"><i>src</i> &gt; <i>dst</i>:
Flags [<i>tcpflags</i>], seq <i>data-seqno</i>, ack
<i>ackno</i>, win <i>window</i>, urg <i>urgent</i>, options
[<i>opts</i>], length <i>len</i></p>

<p style="margin-left:11%;"><i>Src</i> and <i>dst</i> are
the source and destination IP addresses and ports.
<i>Tcpflags</i> are some combination of S (SYN), F (FIN), P
(PUSH), R (RST), U (URG), W (ECN CWR), E (ECN-Echo) or
&rsquo;.&rsquo; (ACK), or &rsquo;none&rsquo; if no flags are
set. <i>Data-seqno</i> describes the portion of sequence
space covered by the data in this packet (see example
below). <i>Ackno</i> is sequence number of the next data
expected the other direction on this connection.
<i>Window</i> is the number of bytes of receive buffer space
available the other direction on this connection. <i>Urg</i>
indicates there is &rsquo;urgent&rsquo; data in the packet.
<i>Opts</i> are TCP options (e.g., mss 1024). <i>Len</i> is
the length of payload data.</p>

<p style="margin-left:11%; margin-top: 1em"><i>Iptype</i>,
<i>Src</i>, <i>dst</i>, and <i>flags</i> are always present.
The other fields depend on the contents of the
packet&rsquo;s TCP protocol header and are output only if
appropriate.</p>

<p style="margin-left:11%; margin-top: 1em">Here is the
opening portion of an rlogin from host <i>rtsg</i> to host
<i>csam</i>.</p>

<p style="margin-left:22%;"><small>IP rtsg.1023 &gt;
csam.login: Flags [S], seq 768512:768512, win 4096, opts
[mss 1024] <br>
IP csam.login &gt; rtsg.1023: Flags [S.], seq,
947648:947648, ack 768513, win 4096, opts [mss 1024] <br>
IP rtsg.1023 &gt; csam.login: Flags [.], ack 1, win 4096
<br>
IP rtsg.1023 &gt; csam.login: Flags [P.], seq 1:2, ack 1,
win 4096, length 1 <br>
IP csam.login &gt; rtsg.1023: Flags [.], ack 2, win 4096
<br>
IP rtsg.1023 &gt; csam.login: Flags [P.], seq 2:21, ack 1,
win 4096, length 19 <br>
IP csam.login &gt; rtsg.1023: Flags [P.], seq 1:2, ack 21,
win 4077, length 1 <br>
IP csam.login &gt; rtsg.1023: Flags [P.], seq 2:3, ack 21,
win 4077, urg 1, length 1 <br>
IP csam.login &gt; rtsg.1023: Flags [P.], seq 3:4, ack 21,
win 4077, urg 1, length 1</small></p>

<p style="margin-left:11%;">The first line says that TCP
port 1023 on rtsg sent a packet to port <i>login</i> on
csam. The <b>S</b> indicates that the <i>SYN</i> flag was
set. The packet sequence number was 768512 and it contained
no data. (The notation is &rsquo;first:last&rsquo; which
means &rsquo;sequence numbers <i>first</i> up to but not
including <i>last</i>.) There was no piggy-backed ack, the
available receive window was 4096 bytes and there was a
max-segment-size option requesting an mss of 1024 bytes.</p>

<p style="margin-left:11%; margin-top: 1em">Csam replies
with a similar packet except it includes a piggy-backed ack
for rtsg&rsquo;s SYN. Rtsg then acks csam&rsquo;s SYN. The
&rsquo;.&rsquo; means the ACK flag was set. The packet
contained no data so there is no data sequence number or
length. Note that the ack sequence number is a small integer
(1). The first time <i>tcpdump</i> sees a TCP
&rsquo;conversation&rsquo;, it prints the sequence number
from the packet. On subsequent packets of the conversation,
the difference between the current packet&rsquo;s sequence
number and this initial sequence number is printed. This
means that sequence numbers after the first can be
interpreted as relative byte positions in the
conversation&rsquo;s data stream (with the first data byte
each direction being &rsquo;1&rsquo;). &rsquo;-S&rsquo; will
override this feature, causing the original sequence numbers
to be output.</p>

<p style="margin-left:11%; margin-top: 1em">On the 6th
line, rtsg sends csam 19 bytes of data (bytes 2 through 20
in the rtsg &rarr; csam side of the conversation). The PUSH
flag is set in the packet. On the 7th line, csam says
it&rsquo;s received data sent by rtsg up to but not
including byte 21. Most of this data is apparently sitting
in the socket buffer since csam&rsquo;s receive window has
gotten 19 bytes smaller. Csam also sends one byte of data to
rtsg in this packet. On the 8th and 9th lines, csam sends
two bytes of urgent, pushed data to rtsg.</p>

<p style="margin-left:11%; margin-top: 1em">If the snapshot
was small enough that <i>tcpdump</i> didn&rsquo;t capture
the full TCP header, it interprets as much of the header as
it can and then reports
&rsquo;&rsquo;[|<i>tcp</i>]&rsquo;&rsquo; to indicate the
remainder could not be interpreted. If the header contains a
bogus option (one with a length that&rsquo;s either too
small or beyond the end of the header), <i>tcpdump</i>
reports it as &rsquo;&rsquo;[<i>bad opt</i>]&rsquo;&rsquo;
and does not interpret any further options (since it&rsquo;s
impossible to tell where they start). If the header length
indicates options are present but the IP datagram length is
not long enough for the options to actually be there,
<i>tcpdump</i> reports it as &rsquo;&rsquo;[<i>bad hdr
length</i>]&rsquo;&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Capturing
TCP packets with particular flag combinations (SYN-ACK,
URG-ACK, etc.)</b></p>

<p style="margin-left:11%; margin-top: 1em">There are 8
bits in the control bits section of the TCP header:</p>

<p style="margin-left:22%; margin-top: 1em"><i>CWR | ECE |
URG | ACK | PSH | RST | SYN | FIN</i></p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
assume that we want to watch packets used in establishing a
TCP connection. Recall that TCP uses a 3-way handshake
protocol when it initializes a new connection; the
connection sequence with regard to the TCP control bits
is</p>

<p style="margin-left:22%; margin-top: 1em">1) Caller sends
SYN <br>
2) Recipient responds with SYN, ACK <br>
3) Caller sends ACK</p>

<p style="margin-left:11%; margin-top: 1em">Now we&rsquo;re
interested in capturing packets that have only the SYN bit
set (Step 1). Note that we don&rsquo;t want packets from
step 2 (SYN-ACK), just a plain initial SYN. What we need is
a correct filter expression for <i>tcpdump</i>.</p>

<p style="margin-left:11%; margin-top: 1em">Recall the
structure of a TCP header without options:</p>

<p style="margin-left:11%; margin-top: 1em">0 15 31 <br>

-----------------------------------------------------------------
<br>
| source port | destination port | <br>

-----------------------------------------------------------------
<br>
| sequence number | <br>

-----------------------------------------------------------------
<br>
| acknowledgment number | <br>

-----------------------------------------------------------------
<br>
| HL | rsvd |C|E|U|A|P|R|S|F| window size | <br>

-----------------------------------------------------------------
<br>
| TCP checksum | urgent pointer | <br>

-----------------------------------------------------------------</p>

<p style="margin-left:11%; margin-top: 1em">A TCP header
usually holds 20 octets of data, unless options are present.
The first line of the graph contains octets 0 - 3, the
second line shows octets 4 - 7 etc.</p>

<p style="margin-left:11%; margin-top: 1em">Starting to
count with 0, the relevant TCP control bits are contained in
octet 13:</p>

<p style="margin-left:11%; margin-top: 1em">0 7| 15| 23| 31
<br>

----------------|---------------|---------------|----------------
<br>
| HL | rsvd |C|E|U|A|P|R|S|F| window size | <br>

----------------|---------------|---------------|----------------
<br>
| | 13th octet | | |</p>

<p style="margin-left:11%; margin-top: 1em">Let&rsquo;s
have a closer look at octet no. 13:</p>

<p style="margin-left:11%; margin-top: 1em">| | <br>
|---------------| <br>
|C|E|U|A|P|R|S|F| <br>
|---------------| <br>
|7 5 3 0|</p>

<p style="margin-left:11%; margin-top: 1em">These are the
TCP control bits we are interested in. We have numbered the
bits in this octet from 0 to 7, right to left, so the PSH
bit is bit number 3, while the URG bit is number 5.</p>

<p style="margin-left:11%; margin-top: 1em">Recall that we
want to capture packets with only SYN set. Let&rsquo;s see
what happens to octet 13 if a TCP datagram arrives with the
SYN bit set in its header:</p>


<p style="margin-left:11%; margin-top: 1em">|C|E|U|A|P|R|S|F|
<br>
|---------------| <br>
|0 0 0 0 0 0 1 0| <br>
|---------------| <br>
|7 6 5 4 3 2 1 0|</p>

<p style="margin-left:11%; margin-top: 1em">Looking at the
control bits section we see that only bit number 1 (SYN) is
set.</p>

<p style="margin-left:11%; margin-top: 1em">Assuming that
octet number 13 is an 8-bit unsigned integer in network byte
order, the binary value of this octet is</p>

<p style="margin-left:22%; margin-top: 1em">00000010</p>

<p style="margin-left:11%; margin-top: 1em">and its decimal
representation is</p>

<p style="margin-left:11%; margin-top: 1em">7 6 5 4 3 2 1 0
<br>
0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2 = 2</p>

<p style="margin-left:11%; margin-top: 1em">We&rsquo;re
almost done, because now we know that if only SYN is set,
the value of the 13th octet in the TCP header, when
interpreted as a 8-bit unsigned integer in network byte
order, must be exactly 2.</p>

<p style="margin-left:11%; margin-top: 1em">This
relationship can be expressed as</p>

<p style="margin-left:22%;"><b>tcp[13] == 2</b></p>

<p style="margin-left:11%; margin-top: 1em">We can use this
expression as the filter for <i>tcpdump</i> in order to
watch packets which have only SYN set:</p>

<p style="margin-left:22%;"><b>tcpdump -i xl0 tcp[13] ==
2</b></p>

<p style="margin-left:11%; margin-top: 1em">The expression
says &quot;let the 13th octet of a TCP datagram have the
decimal value 2&quot;, which is exactly what we want.</p>

<p style="margin-left:11%; margin-top: 1em">Now,
let&rsquo;s assume that we need to capture SYN packets, but
we don&rsquo;t care if ACK or any other TCP control bit is
set at the same time. Let&rsquo;s see what happens to octet
13 when a TCP datagram with SYN-ACK set arrives:</p>


<p style="margin-left:11%; margin-top: 1em">|C|E|U|A|P|R|S|F|
<br>
|---------------| <br>
|0 0 0 1 0 0 1 0| <br>
|---------------| <br>
|7 6 5 4 3 2 1 0|</p>

<p style="margin-left:11%; margin-top: 1em">Now bits 1 and
4 are set in the 13th octet. The binary value of octet 13
is</p>

<p style="margin-left:22%; margin-top: 1em">00010010</p>

<p style="margin-left:11%; margin-top: 1em">which
translates to decimal</p>

<p style="margin-left:11%; margin-top: 1em">7 6 5 4 3 2 1 0
<br>
0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2 = 18</p>

<p style="margin-left:11%; margin-top: 1em">Now we
can&rsquo;t just use &rsquo;tcp[13] == 18&rsquo; in the
<i>tcpdump</i> filter expression, because that would select
only those packets that have SYN-ACK set, but not those with
only SYN set. Remember that we don&rsquo;t care if ACK or
any other control bit is set as long as SYN is set.</p>

<p style="margin-left:11%; margin-top: 1em">In order to
achieve our goal, we need to logically AND the binary value
of octet 13 with some other value to preserve the SYN bit.
We know that we want SYN to be set in any case, so
we&rsquo;ll logically AND the value in the 13th octet with
the binary value of a SYN:</p>

<p style="margin-left:11%; margin-top: 1em">00010010
SYN-ACK 00000010 SYN <br>
AND 00000010 (we want SYN) AND 00000010 (we want SYN) <br>
-------- -------- <br>
= 00000010 = 00000010</p>

<p style="margin-left:11%; margin-top: 1em">We see that
this AND operation delivers the same result regardless
whether ACK or another TCP control bit is set. The decimal
representation of the AND value as well as the result of
this operation is 2 (binary 00000010), so we know that for
packets with SYN set the following relation must hold
true:</p>

<p style="margin-left:22%; margin-top: 1em">( ( value of
octet 13 ) AND ( 2 ) ) == ( 2 )</p>

<p style="margin-left:11%; margin-top: 1em">This points us
to the <i>tcpdump</i> filter expression</p>

<p style="margin-left:22%;"><b>tcpdump -i xl0
&rsquo;tcp[13] &amp; 2 == 2&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">Some offsets
and field values may be expressed as names rather than as
numeric values. For example tcp[13] may be replaced with
tcp[tcpflags]. The following TCP flag field values are also
available: tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-act,
tcp-urg.</p>

<p style="margin-left:11%; margin-top: 1em">This can be
demonstrated as:</p>

<p style="margin-left:22%;"><b>tcpdump -i xl0
&rsquo;tcp[tcpflags] &amp; tcp-push != 0&rsquo;</b></p>

<p style="margin-left:11%; margin-top: 1em">Note that you
should use single quotes or a backslash in the expression to
hide the AND (&rsquo;&amp;&rsquo;) special character from
the shell.</p>

<p style="margin-left:11%; margin-top: 1em"><b>UDP
Packets</b></p>

<p style="margin-left:11%; margin-top: 1em">UDP format is
illustrated by this rwho packet:</p>

<p style="margin-left:22%;">actinide.who &gt;
broadcast.who: udp 84</p>

<p style="margin-left:11%;">This says that port <i>who</i>
on host <i>actinide</i> sent a udp datagram to port
<i>who</i> on host <i>broadcast</i>, the Internet broadcast
address. The packet contained 84 bytes of user data.</p>

<p style="margin-left:11%; margin-top: 1em">Some UDP
services are recognized (from the source or destination port
number) and the higher level protocol information printed.
In particular, Domain Name service requests (RFC-1034/1035)
and Sun RPC calls (RFC-1050) to NFS.</p>

<p style="margin-left:11%; margin-top: 1em"><b>UDP Name
Server Requests</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>(N.B.:The
following description assumes familiarity with the Domain
Service protocol described in RFC-1035. If you are not
familiar with the protocol, the following description will
appear to be written in greek.)</i></p>

<p style="margin-left:11%; margin-top: 1em">Name server
requests are formatted as</p>

<p style="margin-left:22%;"><i>src &gt; dst: id op? flags
qtype qclass name (len)</i> <br>
h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu.
(37)</p>

<p style="margin-left:11%;">Host <i>h2opolo</i> asked the
domain server on <i>helios</i> for an address record
(qtype=A) associated with the name
<i>ucbvax.berkeley.edu.</i> The query id was
&rsquo;3&rsquo;. The &rsquo;+&rsquo; indicates the
<i>recursion desired</i> flag was set. The query length was
37 bytes, not including the UDP and IP protocol headers. The
query operation was the normal one, <i>Query</i>, so the op
field was omitted. If the op had been anything else, it
would have been printed between the &rsquo;3&rsquo; and the
&rsquo;+&rsquo;. Similarly, the qclass was the normal one,
<i>C_IN</i>, and omitted. Any other qclass would have been
printed immediately after the &rsquo;A&rsquo;.</p>

<p style="margin-left:11%; margin-top: 1em">A few anomalies
are checked and may result in extra fields enclosed in
square brackets: If a query contains an answer, authority
records or additional records section, <i>ancount</i>,
<i>nscount</i>, or <i>arcount</i> are printed as
&rsquo;[<i>n</i>a]&rsquo;, &rsquo;[<i>n</i>n]&rsquo; or
&rsquo;[<i>n</i>au]&rsquo; where <i>n</i> is the appropriate
count. If any of the response bits are set (AA, RA or rcode)
or any of the &rsquo;must be zero&rsquo; bits are set in
bytes two and three, &rsquo;[b2&amp;3=<i>x</i>]&rsquo; is
printed, where <i>x</i> is the hex value of header bytes two
and three.</p>

<p style="margin-left:11%; margin-top: 1em"><b>UDP Name
Server Responses</b></p>

<p style="margin-left:11%; margin-top: 1em">Name server
responses are formatted as</p>

<p style="margin-left:22%;"><i>src &gt; dst: id op rcode
flags a/n/au type class data (len)</i> <br>
helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3
(273) <br>
helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)</p>

<p style="margin-left:11%;">In the first example,
<i>helios</i> responds to query id 3 from <i>h2opolo</i>
with 3 answer records, 3 name server records and 7
additional records. The first answer record is type A
(address) and its data is internet address 128.32.137.3. The
total size of the response was 273 bytes, excluding UDP and
IP headers. The op (Query) and response code (NoError) were
omitted, as was the class (C_IN) of the A record.</p>

<p style="margin-left:11%; margin-top: 1em">In the second
example, <i>helios</i> responds to query 2 with a response
code of non-existent domain (NXDomain) with no answers, one
name server and no authority records. The &rsquo;*&rsquo;
indicates that the <i>authoritative answer</i> bit was set.
Since there were no answers, no type, class or data were
printed.</p>

<p style="margin-left:11%; margin-top: 1em">Other flag
characters that might appear are &rsquo;-&rsquo; (recursion
available, RA, <i>not</i> set) and &rsquo;|&rsquo;
(truncated message, TC, set). If the &rsquo;question&rsquo;
section doesn&rsquo;t contain exactly one entry,
&rsquo;[<i>n</i>q]&rsquo; is printed.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SMB/CIFS
decoding</b></p>

<p style="margin-left:11%; margin-top: 1em"><i>tcpdump</i>
now includes fairly extensive SMB/CIFS/NBT decoding for data
on UDP/137, UDP/138 and TCP/139. Some primitive decoding of
IPX and NetBEUI SMB data is also done.</p>

<p style="margin-left:11%; margin-top: 1em">By default a
fairly minimal decode is done, with a much more detailed
decode done if -v is used. Be warned that with -v a single
SMB packet may take up a page or more, so only use -v if you
really want all the gory details.</p>

<p style="margin-left:11%; margin-top: 1em">For information
on SMB packet formats and what all the fields mean see
www.cifs.org or the pub/samba/specs/ directory on your
favorite samba.org mirror site. The SMB patches were written
by Andrew Tridgell (tridge@samba.org).</p>

<p style="margin-left:11%; margin-top: 1em"><b>NFS Requests
and Replies</b></p>

<p style="margin-left:11%; margin-top: 1em">Sun NFS
(Network File System) requests and replies are printed
as:</p>

<p style="margin-left:22%;"><i>src.sport &gt; dst.nfs: NFS
request xid xid len op args <br>
src.nfs &gt; dst.dport: NFS reply xid xid reply stat len op
results</i> <br>
sushi.1023 &gt; wrl.nfs: NFS request xid 26377</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="7%"></td>
<td width="85%">


<p>112 readlink fh 21,24/10.73165</p></td></tr>
</table>

<p style="margin-left:22%;">wrl.nfs &gt; sushi.1023: NFS
reply xid 26377</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>reply ok 40 readlink &quot;../var&quot;</p></td></tr>
</table>

<p style="margin-left:22%;">sushi.1022 &gt; wrl.nfs: NFS
request xid 8219</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>144 lookup fh 9,74/4096.6878 &quot;xcolors&quot;</p></td></tr>
</table>

<p style="margin-left:22%;">wrl.nfs &gt; sushi.1022: NFS
reply xid 8219</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>reply ok 128 lookup fh 9,74/4134.3150</p></td></tr>
</table>

<p style="margin-left:11%;">In the first line, host
<i>sushi</i> sends a transaction with id <i>26377</i> to
<i>wrl</i>. The request was 112 bytes, excluding the UDP and
IP headers. The operation was a <i>readlink</i> (read
symbolic link) on file handle (<i>fh</i>)
21,24/10.731657119. (If one is lucky, as in this case, the
file handle can be interpreted as a major,minor device
number pair, followed by the inode number and generation
number.) In the second line, <i>wrl</i> replies
&rsquo;ok&rsquo; with the same transaction id and the
contents of the link.</p>

<p style="margin-left:11%; margin-top: 1em">In the third
line, <i>sushi</i> asks (using a new transaction id)
<i>wrl</i> to lookup the name &rsquo;<i>xcolors</i>&rsquo;
in directory file 9,74/4096.6878. In the fourth line,
<i>wrl</i> sends a reply with the respective transaction
id.</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
data printed depends on the operation type. The format is
intended to be self explanatory if read in conjunction with
an NFS protocol spec. Also note that older versions of
tcpdump printed NFS packets in a slightly different format:
the transaction id (xid) would be printed instead of the
non-NFS port number of the packet.</p>

<p style="margin-left:11%; margin-top: 1em">If the -v
(verbose) flag is given, additional information is printed.
For example:</p>

<p style="margin-left:22%;">sushi.1023 &gt; wrl.nfs: NFS
request xid 79658</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>148 read fh 21,11/12.195 8192 bytes @ 24576</p></td></tr>
</table>

<p style="margin-left:22%;">wrl.nfs &gt; sushi.1023: NFS
reply xid 79658</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>reply ok 1472 read REG 100664 ids 417/0 sz 29388</p></td></tr>
</table>

<p style="margin-left:11%;">(-v also prints the IP header
TTL, ID, length, and fragmentation fields, which have been
omitted from this example.) In the first line, <i>sushi</i>
asks <i>wrl</i> to read 8192 bytes from file 21,11/12.195,
at byte offset 24576. <i>Wrl</i> replies &rsquo;ok&rsquo;;
the packet shown on the second line is the first fragment of
the reply, and hence is only 1472 bytes long (the other
bytes will follow in subsequent fragments, but these
fragments do not have NFS or even UDP headers and so might
not be printed, depending on the filter expression used).
Because the -v flag is given, some of the file attributes
(which are returned in addition to the file data) are
printed: the file type (&rsquo;&rsquo;REG&rsquo;&rsquo;, for
regular file), the file mode (in octal), the uid and gid,
and the file size.</p>

<p style="margin-left:11%; margin-top: 1em">If the -v flag
is given more than once, even more details are printed.</p>

<p style="margin-left:11%; margin-top: 1em">Note that NFS
requests are very large and much of the detail won&rsquo;t
be printed unless <i>snaplen</i> is increased. Try using
&rsquo;<b>-s 192</b>&rsquo; to watch NFS traffic.</p>

<p style="margin-left:11%; margin-top: 1em">NFS reply
packets do not explicitly identify the RPC operation.
Instead, <i>tcpdump</i> keeps track of
&rsquo;&rsquo;recent&rsquo;&rsquo; requests, and matches
them to the replies using the transaction ID. If a reply
does not closely follow the corresponding request, it might
not be parsable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>AFS Requests
and Replies</b></p>

<p style="margin-left:11%; margin-top: 1em">Transarc AFS
(Andrew File System) requests and replies are printed
as:</p>

<p style="margin-left:22%; margin-top: 1em"><i>src.sport
&gt; dst.dport: rx packet-type <br>
src.sport &gt; dst.dport: rx packet-type service call
call-name args <br>
src.sport &gt; dst.dport: rx packet-type service reply
call-name args</i> <br>
elvis.7001 &gt; pike.afsfs:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>rx data fs call rename old fid 536876964/1/1
&quot;.newsrc.new&quot;</p> </td></tr>
<tr valign="top" align="left">
<td width="8%"></td>
<td width="92%">


<p>new fid 536876964/1/1 &quot;.newsrc&quot;</p></td></tr>
</table>

<p style="margin-left:22%;">pike.afsfs &gt; elvis.7001: rx
data fs reply rename</p>

<p style="margin-left:11%;">In the first line, host elvis
sends a RX packet to pike. This was a RX data packet to the
fs (fileserver) service, and is the start of an RPC call.
The RPC call was a rename, with the old directory file id of
536876964/1/1 and an old filename of
&rsquo;.newsrc.new&rsquo;, and a new directory file id of
536876964/1/1 and a new filename of &rsquo;.newsrc&rsquo;.
The host pike responds with a RPC reply to the rename call
(which was successful, because it was a data packet and not
an abort packet).</p>

<p style="margin-left:11%; margin-top: 1em">In general, all
AFS RPCs are decoded at least by RPC call name. Most AFS
RPCs have at least some of the arguments decoded (generally
only the &rsquo;interesting&rsquo; arguments, for some
definition of interesting).</p>

<p style="margin-left:11%; margin-top: 1em">The format is
intended to be self-describing, but it will probably not be
useful to people who are not familiar with the workings of
AFS and RX.</p>

<p style="margin-left:11%; margin-top: 1em">If the -v
(verbose) flag is given twice, acknowledgement packets and
additional header information is printed, such as the RX
call ID, call number, sequence number, serial number, and
the RX packet flags.</p>

<p style="margin-left:11%; margin-top: 1em">If the -v flag
is given twice, additional information is printed, such as
the RX call ID, serial number, and the RX packet flags. The
MTU negotiation information is also printed from RX ack
packets.</p>

<p style="margin-left:11%; margin-top: 1em">If the -v flag
is given three times, the security index and service id are
printed.</p>

<p style="margin-left:11%; margin-top: 1em">Error codes are
printed for abort packets, with the exception of Ubik beacon
packets (because abort packets are used to signify a yes
vote for the Ubik protocol).</p>

<p style="margin-left:11%; margin-top: 1em">Note that AFS
requests are very large and many of the arguments
won&rsquo;t be printed unless <i>snaplen</i> is increased.
Try using &rsquo;<b>-s 256</b>&rsquo; to watch AFS
traffic.</p>

<p style="margin-left:11%; margin-top: 1em">AFS reply
packets do not explicitly identify the RPC operation.
Instead, <i>tcpdump</i> keeps track of
&rsquo;&rsquo;recent&rsquo;&rsquo; requests, and matches
them to the replies using the call number and service ID. If
a reply does not closely follow the corresponding request,
it might not be parsable.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KIP
AppleTalk (DDP in UDP)</b></p>

<p style="margin-left:11%; margin-top: 1em">AppleTalk DDP
packets encapsulated in UDP datagrams are de-encapsulated
and dumped as DDP packets (i.e., all the UDP header
information is discarded). The file <i>/etc/atalk.names</i>
is used to translate AppleTalk net and node numbers to
names. Lines in this file have the form</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p><i>number</i></p></td>
<td width="8%"></td>
<td width="69%">


<p><i>name</i></p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p>1.254</p></td>
<td width="8%"></td>
<td width="69%">
</td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%"></td>
<td width="8%"></td>
<td width="69%">


<p>ether</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p>16.1</p></td>
<td width="8%">
</td>
<td width="69%">


<p>icsd-net</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="-14%"></td>
<td width="7%"></td>
<td width="8%">


<p>1.254.110</p></td>
<td width="8%"></td>
<td width="69%">


<p>ace</p></td></tr>
</table>

<p style="margin-left:11%;">The first two lines give the
names of AppleTalk networks. The third line gives the name
of a particular host (a host is distinguished from a net by
the 3rd octet in the number - a net number <i>must</i> have
two octets and a host number <i>must</i> have three octets.)
The number and name should be separated by whitespace
(blanks or tabs). The <i>/etc/atalk.names</i> file may
contain blank lines or comment lines (lines starting with a
&rsquo;#&rsquo;).</p>

<p style="margin-left:11%; margin-top: 1em">AppleTalk
addresses are printed in the form</p>

<p style="margin-left:22%;"><i>net.host.port</i></p>

<p style="margin-left:22%; margin-top: 1em">144.1.209.2
&gt; icsd-net.112.220 <br>
office.2 &gt; icsd-net.112.220 <br>
jssmag.149.235 &gt; icsd-net.2</p>

<p style="margin-left:11%;">(If the <i>/etc/atalk.names</i>
doesn&rsquo;t exist or doesn&rsquo;t contain an entry for
some AppleTalk host/net number, addresses are printed in
numeric form.) In the first example, NBP (DDP port 2) on net
144.1 node 209 is sending to whatever is listening on port
220 of net icsd node 112. The second line is the same except
the full name of the source node is known
(&rsquo;office&rsquo;). The third line is a send from port
235 on net jssmag node 149 to broadcast on the icsd-net NBP
port (note that the broadcast address (255) is indicated by
a net name with no host number - for this reason it&rsquo;s
a good idea to keep node names and net names distinct in
/etc/atalk.names).</p>

<p style="margin-left:11%; margin-top: 1em">NBP (name
binding protocol) and ATP (AppleTalk transaction protocol)
packets have their contents interpreted. Other protocols
just dump the protocol name (or number if no name is
registered for the protocol) and packet size.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NBP
packets</b> are formatted like the following examples:</p>

<p style="margin-left:22%;"><small>icsd-net.112.220 &gt;
jssmag.2: nbp-lkup 190: &quot;=:LaserWriter@*&quot; <br>
jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190:
&quot;RM1140:LaserWriter@*&quot; 250 <br>
techpit.2 &gt; icsd-net.112.220: nbp-reply 190:
&quot;techpit:LaserWriter@*&quot; 186</small></p>

<p style="margin-left:11%;">The first line is a name lookup
request for laserwriters sent by net icsd host 112 and
broadcast on net jssmag. The nbp id for the lookup is 190.
The second line shows a reply for this request (note that it
has the same id) from host jssmag.209 saying that it has a
laserwriter resource named &quot;RM1140&quot; registered on
port 250. The third line is another reply to the same
request saying host techpit has laserwriter
&quot;techpit&quot; registered on port 186.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ATP
packet</b> formatting is demonstrated by the following
example:</p>

<p style="margin-left:22%;"><small>jssmag.209.165 &gt;
helios.132: atp-req 12266&lt;0-7&gt; 0xae030001 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512)
0xae040000 <br>
jssmag.209.165 &gt; helios.132: atp-req 12266&lt;3,5&gt;
0xae030001 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512)
0xae040000 <br>
helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512)
0xae040000 <br>
jssmag.209.165 &gt; helios.132: atp-rel 12266&lt;0-7&gt;
0xae030001 <br>
jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt;
0xae030002</small></p>

<p style="margin-left:11%;">Jssmag.209 initiates
transaction id 12266 with host helios by requesting up to 8
packets (the &rsquo;&lt;0-7&gt;&rsquo;). The hex number at
the end of the line is the value of the
&rsquo;userdata&rsquo; field in the request.</p>

<p style="margin-left:11%; margin-top: 1em">Helios responds
with 8 512-byte packets. The &rsquo;:digit&rsquo; following
the transaction id gives the packet sequence number in the
transaction and the number in parens is the amount of data
in the packet, excluding the atp header. The &rsquo;*&rsquo;
on packet 7 indicates that the EOM bit was set.</p>

<p style="margin-left:11%; margin-top: 1em">Jssmag.209 then
requests that packets 3 &amp; 5 be retransmitted. Helios
resends them then jssmag.209 releases the transaction.
Finally, jssmag.209 initiates the next request. The
&rsquo;*&rsquo; on the request indicates that XO
(&rsquo;exactly once&rsquo;) was <i>not</i> set.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">stty(1),
pcap(3PCAP), bpf(4), nit(4P), pcap-savefile(5),
pcap-filter(7), pcap-tstamp(7)</p>


<p style="margin-left:22%; margin-top: 1em"><i>http://www.iana.org/assignments/media-types/application/vnd.tcpdump.pcap</i></p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The original
authors are:</p>

<p style="margin-left:11%; margin-top: 1em">Van Jacobson,
Craig Leres and Steven McCanne, all of the Lawrence Berkeley
National Laboratory, University of California, Berkeley,
CA.</p>

<p style="margin-left:11%; margin-top: 1em">It is currently
being maintained by tcpdump.org.</p>

<p style="margin-left:11%; margin-top: 1em">The current
version is available via http:</p>


<p style="margin-left:22%; margin-top: 1em"><i>https://www.tcpdump.org/</i></p>

<p style="margin-left:11%; margin-top: 1em">The original
distribution is available via anonymous ftp:</p>


<p style="margin-left:22%; margin-top: 1em"><i>ftp://ftp.ee.lbl.gov/old/tcpdump.tar.Z</i></p>

<p style="margin-left:11%; margin-top: 1em">IPv6/IPsec
support is added by WIDE/KAME project. This program uses
Eric Young&rsquo;s SSLeay library, under specific
configurations.</p>

<h2>BUGS
<a name="BUGS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">To report a
security issue please send an e-mail to
security@tcpdump.org.</p>

<p style="margin-left:11%; margin-top: 1em">To report bugs
and other problems, contribute patches, request a feature,
provide generic feedback etc please see the file
<i>CONTRIBUTING</i> in the tcpdump source tree root.</p>

<p style="margin-left:11%; margin-top: 1em">NIT
doesn&rsquo;t let you watch your own outbound traffic, BPF
will. We recommend that you use the latter.</p>

<p style="margin-left:11%; margin-top: 1em">On Linux
systems with 2.0[.x] kernels:</p>

<p style="margin-left:22%; margin-top: 1em">packets on the
loopback device will be seen twice;</p>

<p style="margin-left:22%; margin-top: 1em">packet
filtering cannot be done in the kernel, so that all packets
must be copied from the kernel in order to be filtered in
user mode;</p>

<p style="margin-left:22%; margin-top: 1em">all of a
packet, not just the part that&rsquo;s within the snapshot
length, will be copied from the kernel (the 2.0[.x] packet
capture mechanism, if asked to copy only part of a packet to
userland, will not report the true length of the packet;
this would cause most IP packets to get an error from
<b>tcpdump</b>);</p>

<p style="margin-left:22%; margin-top: 1em">capturing on
some PPP devices won&rsquo;t work correctly.</p>

<p style="margin-left:11%; margin-top: 1em">We recommend
that you upgrade to a 2.2 or later kernel.</p>

<p style="margin-left:11%; margin-top: 1em">Some attempt
should be made to reassemble IP fragments or, at least to
compute the right length for the higher level protocol.</p>

<p style="margin-left:11%; margin-top: 1em">Name server
inverse queries are not dumped correctly: the (empty)
question section is printed rather than real query in the
answer section. Some believe that inverse queries are
themselves a bug and prefer to fix the program generating
them rather than <i>tcpdump</i>.</p>

<p style="margin-left:11%; margin-top: 1em">A packet trace
that crosses a daylight savings time change will give skewed
time stamps (the time change is ignored).</p>

<p style="margin-left:11%; margin-top: 1em">Filter
expressions on fields other than those in Token Ring headers
will not correctly handle source-routed Token Ring
packets.</p>

<p style="margin-left:11%; margin-top: 1em">Filter
expressions on fields other than those in 802.11 headers
will not correctly handle 802.11 data packets with both To
DS and From DS set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ip6
proto</b> should chase header chain, but at this moment it
does not. <b>ip6 protochain</b> is supplied for this
behavior.</p>

<p style="margin-left:11%; margin-top: 1em">Arithmetic
expression against transport layer headers, like
<b>tcp[0]</b>, does not work against IPv6 packets. It only
looks at IPv4 packets.</p>
<hr>
</body>
</html>
