<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Thu Sep  8 02:41:41 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>FFMPEG-PROTOCOLS</title>

</head>
<body>

<h1 align="center">FFMPEG-PROTOCOLS</h1>

<a href="#NAME">NAME</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#PROTOCOL OPTIONS">PROTOCOL OPTIONS</a><br>
<a href="#PROTOCOLS">PROTOCOLS</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>
<a href="#AUTHORS">AUTHORS</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">ffmpeg-protocols
- FFmpeg protocols</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This document
describes the input and output protocols provided by the
libavformat library.</p>

<h2>PROTOCOL OPTIONS
<a name="PROTOCOL OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The libavformat
library provides some generic global options, which can be
set on all the protocols. In addition each protocol may
support so-called private options, which are specific for
that component.</p>

<p style="margin-left:11%; margin-top: 1em">Options may be
set by specifying -<i>option value</i> in the FFmpeg tools,
or by setting the value explicitly in the
&quot;AVFormatContext&quot; options or using the
<i>libavutil/opt.h</i> <small>API</small> for programmatic
use.</p>

<p style="margin-left:11%; margin-top: 1em">The list of
supported options follows: <b><br>
protocol_whitelist</b> <i>list</i>
<b>(</b><i>input</i><b>)</b></p>

<p style="margin-left:17%;">Set a &quot;,&quot;-separated
list of allowed protocols. &quot; <small>ALL&quot;</small>
matches all protocols. Protocols prefixed by &quot;-&quot;
are disabled. All protocols are allowed by default but
protocols used by an another protocol (nested protocols) are
restricted to a per protocol subset.</p>

<h2>PROTOCOLS
<a name="PROTOCOLS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Protocols are
configured elements in FFmpeg that enable access to
resources that require specific protocols.</p>

<p style="margin-left:11%; margin-top: 1em">When you
configure your FFmpeg build, all the supported protocols are
enabled by default. You can list all available ones using
the configure option &quot;--list-protocols&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">You can disable
all the protocols using the configure option
&quot;--disable-protocols&quot;, and selectively enable a
protocol using the option &quot;--enable-protocol=
<i><small>PROTOCOL</small></i> &quot;, or you can disable a
particular protocol using the option
&quot;--disable-protocol= <i><small>PROTOCOL</small></i>
&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The option
&quot;-protocols&quot; of the ff* tools will display the
list of supported protocols.</p>

<p style="margin-left:11%; margin-top: 1em">All protocols
accept the following options: <b><br>
rw_timeout</b></p>

<p style="margin-left:17%;">Maximum time to wait for
(network) read/write operations to complete, in
microseconds.</p>

<p style="margin-left:11%; margin-top: 1em">A description
of the currently available protocols follows.</p>

<p style="margin-left:11%; margin-top: 1em"><b>async</b>
<br>
Asynchronous data filling wrapper for input stream.</p>

<p style="margin-left:11%; margin-top: 1em">Fill data in a
background thread, to decouple I/O operation from demux
thread.</p>


<p style="margin-left:11%; margin-top: 1em">async:&lt;URL&gt;
<br>
async:http://host/resource <br>
async:cache:http://host/resource</p>

<p style="margin-left:11%; margin-top: 1em"><b>bluray</b>
<br>
Read BluRay playlist.</p>

<p style="margin-left:11%; margin-top: 1em">The accepted
options are: <b><br>
angle</b></p>

<p style="margin-left:17%;">BluRay angle</p>

<p style="margin-left:11%;"><b>chapter</b></p>

<p style="margin-left:17%;">Start chapter (1...N)</p>

<p style="margin-left:11%;"><b>playlist</b></p>

<p style="margin-left:17%;">Playlist to read (
<small>BDMV/PLAYLIST/</small> ?????.mpls)</p>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">Read longest
playlist from BluRay mounted to /mnt/bluray:</p>


<p style="margin-left:11%; margin-top: 1em">bluray:/mnt/bluray</p>

<p style="margin-left:11%; margin-top: 1em">Read angle 2 of
playlist 4 from BluRay mounted to /mnt/bluray, start from
chapter 2:</p>

<p style="margin-left:11%; margin-top: 1em">-playlist 4
-angle 2 -chapter 2 bluray:/mnt/bluray</p>

<p style="margin-left:11%; margin-top: 1em"><b>cache</b>
<br>
Caching wrapper for input stream.</p>

<p style="margin-left:11%; margin-top: 1em">Cache the input
stream to temporary file. It brings seeking capability to
live streams.</p>


<p style="margin-left:11%; margin-top: 1em">cache:&lt;URL&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>concat</b>
<br>
Physical concatenation protocol.</p>

<p style="margin-left:11%; margin-top: 1em">Read and seek
from many resources in sequence as if they were a unique
resource.</p>

<p style="margin-left:11%; margin-top: 1em">A
<small>URL</small> accepted by this protocol has the
syntax:</p>


<p style="margin-left:11%; margin-top: 1em">concat:&lt;URL1&gt;|&lt;URL2&gt;|...|&lt;URLN&gt;</p>

<p style="margin-left:11%; margin-top: 1em">where
<i><small>URL1</small></i> , <i><small>URL2</small></i> ,
..., <i><small>URLN</small></i> are the urls of the resource
to be concatenated, each one possibly specifying a distinct
protocol.</p>

<p style="margin-left:11%; margin-top: 1em">For example to
read a sequence of files <i>split1.mpeg</i>,
<i>split2.mpeg</i>, <i>split3.mpeg</i> with <b>ffplay</b>
use the command:</p>

<p style="margin-left:11%; margin-top: 1em">ffplay
concat:split1.mpeg\|split2.mpeg\|split3.mpeg</p>

<p style="margin-left:11%; margin-top: 1em">Note that you
may need to escape the character &quot;|&quot; which is
special for many shells.</p>

<p style="margin-left:11%; margin-top: 1em"><b>crypto</b>
<br>
AES-encrypted stream reading protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The accepted
options are:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>key</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>Set the <small>AES</small> decryption key binary block
from given hexadecimal representation.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>iv</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>Set the <small>AES</small> decryption initialization
vector binary block from given hexadecimal
representation.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Accepted
<small>URL</small> formats:</p>


<p style="margin-left:11%; margin-top: 1em">crypto:&lt;URL&gt;
<br>
crypto+&lt;URL&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>data</b>
<br>
Data in-line in the <small>URI.</small> See
&lt;<b>http://en.wikipedia.org/wiki/Data_URI_scheme</b>&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">For example, to
convert a <small>GIF</small> file given inline with
<b>ffmpeg</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -i
&quot;data:image/gif;base64,R0lGODdhCAAIAMIEAAAAAAAA//8AAP//AP///////////////ywAAAAACAAIAAADF0gEDLojDgdGiJdJqUX02iB4E8Q9jUMkADs=&quot;
smiley.png</p>

<p style="margin-left:11%; margin-top: 1em"><b>file</b>
<br>
File access protocol.</p>

<p style="margin-left:11%; margin-top: 1em">Read from or
write to a file.</p>

<p style="margin-left:11%; margin-top: 1em">A file
<small>URL</small> can have the form:</p>


<p style="margin-left:11%; margin-top: 1em">file:&lt;filename&gt;</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>filename</i> is the path of the file to read.</p>

<p style="margin-left:11%; margin-top: 1em">An
<small>URL</small> that does not have a protocol prefix will
be assumed to be a file <small>URL.</small> Depending on the
build, an <small>URL</small> that looks like a Windows path
with the drive letter at the beginning will also be assumed
to be a file <small>URL</small> (usually not the case in
builds for unix-like systems).</p>

<p style="margin-left:11%; margin-top: 1em">For example to
read from a file <i>input.mpeg</i> with <b>ffmpeg</b> use
the command:</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -i
file:input.mpeg output.mpeg</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options: <b><br>
truncate</b></p>

<p style="margin-left:17%;">Truncate existing files on
write, if set to 1. A value of 0 prevents truncating.
Default value is 1.</p>

<p style="margin-left:11%;"><b>blocksize</b></p>

<p style="margin-left:17%;">Set I/O operation maximum block
size, in bytes. Default value is &quot;INT_MAX&quot;, which
results in not limiting the requested block size. Setting
this value reasonably low improves user termination request
reaction time, which is valuable for files on slow
medium.</p>

<p style="margin-left:11%;"><b>follow</b></p>

<p style="margin-left:17%;">If set to 1, the protocol will
retry reading at the end of the file, allowing reading files
that still are being written. In order for this to
terminate, you either need to use the rw_timeout option, or
use the interrupt callback (for <small>API</small>
users).</p>

<p style="margin-left:11%;"><b>seekable</b></p>

<p style="margin-left:17%;">Controls if seekability is
advertised on the file. 0 means non-seekable, -1 means auto
(seekable for normal files, non-seekable for named
pipes).</p>

<p style="margin-left:17%; margin-top: 1em">Many demuxers
handle seekable and non-seekable resources differently,
overriding this might speed up opening certain files at the
cost of losing some features (e.g. accurate seeking).</p>

<p style="margin-left:11%; margin-top: 1em"><b>ftp</b>
<small><br>
FTP</small> (File Transfer Protocol).</p>

<p style="margin-left:11%; margin-top: 1em">Read from or
write to remote resources using <small>FTP</small>
protocol.</p>

<p style="margin-left:11%; margin-top: 1em">Following
syntax is required.</p>


<p style="margin-left:11%; margin-top: 1em">ftp://[user[:password]@]server[:port]/path/to/remote/resource.mpeg</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options. <b><br>
timeout</b></p>

<p style="margin-left:17%;">Set timeout in microseconds of
socket I/O operations used by the underlying low level
operation. By default it is set to -1, which means that the
timeout is not specified.</p>


<p style="margin-left:11%;"><b>ftp-anonymous-password</b></p>

<p style="margin-left:17%;">Password used when login as
anonymous user. Typically an e-mail address should be
used.</p>

<p style="margin-left:11%;"><b>ftp-write-seekable</b></p>

<p style="margin-left:17%;">Control seekability of
connection during encoding. If set to 1 the resource is
supposed to be seekable, if set to 0 it is assumed not to be
seekable. Default value is 0.</p>


<p style="margin-left:11%; margin-top: 1em"><small>NOTE:</small>
Protocol can be used as output, but it is recommended to not
do it, unless special care is taken (tests, customized
server configuration etc.). Different <small>FTP</small>
servers behave in different way during seek operation. ff*
tools may produce incomplete content due to server
limitations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>gopher</b>
<br>
Gopher protocol.</p>

<p style="margin-left:11%; margin-top: 1em"><b>hls</b> <br>
Read Apple <small>HTTP</small> Live Streaming compliant
segmented stream as a uniform one. The M3U8 playlists
describing the segments can be remote <small>HTTP</small>
resources or local files, accessed using the standard file
protocol. The nested protocol is declared by specifying
&quot;+<i>proto</i>&quot; after the hls <small>URI</small>
scheme name, where <i>proto</i> is either &quot;file&quot;
or &quot;http&quot;.</p>


<p style="margin-left:11%; margin-top: 1em">hls+http://host/path/to/remote/resource.m3u8
<br>
hls+file://path/to/local/resource.m3u8</p>

<p style="margin-left:11%; margin-top: 1em">Using this
protocol is discouraged - the hls demuxer should work just
as well (if not, please report the issues) and is more
complete. To use the hls demuxer instead, simply use the
direct URLs to the m3u8 files.</p>

<p style="margin-left:11%; margin-top: 1em"><b>http</b>
<small><br>
HTTP</small> (Hyper Text Transfer Protocol).</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options: <b><br>
seekable</b></p>

<p style="margin-left:17%;">Control seekability of
connection. If set to 1 the resource is supposed to be
seekable, if set to 0 it is assumed not to be seekable, if
set to -1 it will try to autodetect if it is seekable.
Default value is -1.</p>

<p style="margin-left:11%;"><b>chunked_post</b></p>

<p style="margin-left:17%;">If set to 1 use chunked
Transfer-Encoding for posts, default is 1.</p>

<p style="margin-left:11%;"><b>content_type</b></p>

<p style="margin-left:17%;">Set a specific content type for
the <small>POST</small> messages or for listen mode.</p>

<p style="margin-left:11%;"><b>http_proxy</b></p>

<p style="margin-left:17%;">set <small>HTTP</small> proxy
to tunnel through e.g. http://example.com:1234</p>

<p style="margin-left:11%;"><b>headers</b></p>

<p style="margin-left:17%;">Set custom <small>HTTP</small>
headers, can override built in default headers. The value
must be a string encoding the headers.</p>

<p style="margin-left:11%;"><b>multiple_requests</b></p>

<p style="margin-left:17%;">Use persistent connections if
set to 1, default is 0.</p>

<p style="margin-left:11%;"><b>post_data</b></p>

<p style="margin-left:17%;">Set custom <small>HTTP</small>
post data.</p>

<p style="margin-left:11%;"><b>referer</b></p>

<p style="margin-left:17%;">Set the Referer header. Include
&rsquo;Referer: <small>URL</small> &rsquo; header in
<small>HTTP</small> request.</p>

<p style="margin-left:11%;"><b>user_agent</b></p>

<p style="margin-left:17%;">Override the User-Agent header.
If not specified the protocol will use a string describing
the libavformat build.
(&quot;Lavf/&lt;version&gt;&quot;)</p>

<p style="margin-left:11%;"><b>user-agent</b></p>

<p style="margin-left:17%;">This is a deprecated option,
you can use user_agent instead it.</p>

<p style="margin-left:11%;"><b>timeout</b></p>

<p style="margin-left:17%;">Set timeout in microseconds of
socket I/O operations used by the underlying low level
operation. By default it is set to -1, which means that the
timeout is not specified.</p>

<p style="margin-left:11%;"><b>reconnect_at_eof</b></p>

<p style="margin-left:17%;">If set then eof is treated like
an error and causes reconnection, this is useful for live /
endless streams.</p>

<p style="margin-left:11%;"><b>reconnect_streamed</b></p>

<p style="margin-left:17%;">If set then even streamed/non
seekable streams will be reconnected on errors.</p>

<p style="margin-left:11%;"><b>reconnect_delay_max</b></p>

<p style="margin-left:17%;">Sets the maximum delay in
seconds after which to give up reconnecting</p>

<p style="margin-left:11%;"><b>mime_type</b></p>

<p style="margin-left:17%;">Export the <small>MIME</small>
type.</p>

<p style="margin-left:11%;"><b>http_version</b></p>

<p style="margin-left:17%;">Exports the <small>HTTP</small>
response version number. Usually &quot;1.0&quot; or
&quot;1.1&quot;.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>icy</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>If set to 1 request <small>ICY</small> (SHOUTcast)
metadata from the server. If the server supports this, the
metadata has to be retrieved by the application by reading
the <b>icy_metadata_headers</b> and
<b>icy_metadata_packet</b> options. The default is 1.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>icy_metadata_headers</b></p>

<p style="margin-left:17%;">If the server supports
<small>ICY</small> metadata, this contains the ICY-specific
<small>HTTP</small> reply headers, separated by newline
characters.</p>

<p style="margin-left:11%;"><b>icy_metadata_packet</b></p>

<p style="margin-left:17%;">If the server supports
<small>ICY</small> metadata, and <b>icy</b> was set to 1,
this contains the last non-empty metadata packet sent by the
server. It should be polled in regular intervals by
applications interested in mid-stream metadata updates.</p>

<p style="margin-left:11%;"><b>cookies</b></p>

<p style="margin-left:17%;">Set the cookies to be sent in
future requests. The format of each cookie is the same as
the value of a Set-Cookie <small>HTTP</small> response
field. Multiple cookies can be delimited by a newline
character.</p>

<p style="margin-left:11%;"><b>offset</b></p>

<p style="margin-left:17%;">Set initial byte offset.</p>

<p style="margin-left:11%;"><b>end_offset</b></p>

<p style="margin-left:17%;">Try to limit the request to
bytes preceding this offset.</p>

<p style="margin-left:11%;"><b>method</b></p>

<p style="margin-left:17%;">When used as a client option it
sets the <small>HTTP</small> method for the request.</p>

<p style="margin-left:17%; margin-top: 1em">When used as a
server option it sets the <small>HTTP</small> method that is
going to be expected from the client(s). If the expected and
the received <small>HTTP</small> method do not match the
client will be given a Bad Request response. When unset the
<small>HTTP</small> method is not checked for now. This will
be replaced by autodetection in the future.</p>

<p style="margin-left:11%;"><b>listen</b></p>

<p style="margin-left:17%;">If set to 1 enables
experimental <small>HTTP</small> server. This can be used to
send data when used as an output option, or read data from a
client with <small>HTTP POST</small> when used as an input
option. If set to 2 enables experimental multi-client
<small>HTTP</small> server. This is not yet implemented in
ffmpeg.c and thus must not be used as a command line
option.</p>

<p style="margin-left:17%; margin-top: 1em"># Server side
(sending): <br>
ffmpeg -i somefile.ogg -c copy -listen 1 -f ogg
http://&lt;server&gt;:&lt;port&gt; <br>
# Client side (receiving): <br>
ffmpeg -i http://&lt;server&gt;:&lt;port&gt; -c copy
somefile.ogg <br>
# Client can also be done with wget: <br>
wget http://&lt;server&gt;:&lt;port&gt; -O somefile.ogg <br>
# Server side (receiving): <br>
ffmpeg -listen 1 -i http://&lt;server&gt;:&lt;port&gt; -c
copy somefile.ogg <br>
# Client side (sending): <br>
ffmpeg -i somefile.ogg -chunked_post 0 -c copy -f ogg
http://&lt;server&gt;:&lt;port&gt; <br>
# Client can also be done with wget: <br>
wget --post-file=somefile.ogg
http://&lt;server&gt;:&lt;port&gt;</p>

<p style="margin-left:11%;"><b>send_expect_100</b></p>

<p style="margin-left:17%;">Send an Expect: 100-continue
header for <small>POST.</small> If set to 1 it will send, if
set to 0 it won&rsquo;t, if set to -1 it will try to send if
it is applicable. Default value is -1.</p>


<p style="margin-left:11%; margin-top: 1em"><i><small>HTTP</small>
Cookies</i></p>

<p style="margin-left:11%; margin-top: 1em">Some
<small>HTTP</small> requests will be denied unless cookie
values are passed in with the request. The <b>cookies</b>
option allows these cookies to be specified. At the very
least, each cookie must specify a value along with a path
and domain. <small>HTTP</small> requests that match both the
domain and path will automatically include the cookie value
in the <small>HTTP</small> Cookie header field. Multiple
cookies can be delimited by a newline.</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax to play a stream specifying a cookie is:</p>

<p style="margin-left:11%; margin-top: 1em">ffplay -cookies
&quot;nlqptid=nltid=tsn; path=/;
domain=somedomain.com;&quot;
http://somedomain.com/somestream.m3u8</p>

<p style="margin-left:11%; margin-top: 1em"><b>Icecast</b>
<br>
Icecast protocol (stream to Icecast servers)</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options: <b><br>
ice_genre</b></p>

<p style="margin-left:17%;">Set the stream genre.</p>

<p style="margin-left:11%;"><b>ice_name</b></p>

<p style="margin-left:17%;">Set the stream name.</p>

<p style="margin-left:11%;"><b>ice_description</b></p>

<p style="margin-left:17%;">Set the stream description.</p>

<p style="margin-left:11%;"><b>ice_url</b></p>

<p style="margin-left:17%;">Set the stream website
<small>URL.</small></p>

<p style="margin-left:11%;"><b>ice_public</b></p>

<p style="margin-left:17%;">Set if the stream should be
public. The default is 0 (not public).</p>

<p style="margin-left:11%;"><b>user_agent</b></p>

<p style="margin-left:17%;">Override the User-Agent header.
If not specified a string of the form
&quot;Lavf/&lt;version&gt;&quot; will be used.</p>

<p style="margin-left:11%;"><b>password</b></p>

<p style="margin-left:17%;">Set the Icecast mountpoint
password.</p>

<p style="margin-left:11%;"><b>content_type</b></p>

<p style="margin-left:17%;">Set the stream content type.
This must be set if it is different from audio/mpeg.</p>

<p style="margin-left:11%;"><b>legacy_icecast</b></p>

<p style="margin-left:17%;">This enables support for
Icecast versions &lt; 2.4.0, that do not support the
<small>HTTP PUT</small> method but the <small>SOURCE</small>
method.</p>


<p style="margin-left:11%; margin-top: 1em">icecast://[&lt;username&gt;[:&lt;password&gt;]@]&lt;server&gt;:&lt;port&gt;/&lt;mountpoint&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>mmst</b>
<small><br>
MMS</small> (Microsoft Media Server) protocol over
<small>TCP.</small></p>

<p style="margin-left:11%; margin-top: 1em"><b>mmsh</b>
<small><br>
MMS</small> (Microsoft Media Server) protocol over
<small>HTTP.</small></p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax is:</p>


<p style="margin-left:11%; margin-top: 1em">mmsh://&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;playpath&gt;]</p>

<p style="margin-left:11%; margin-top: 1em"><b>md5</b>
<small><br>
MD5</small> output protocol.</p>

<p style="margin-left:11%; margin-top: 1em">Computes the
<small>MD5</small> hash of the data to be written, and on
close writes this to the designated output or stdout if none
is specified. It can be used to test muxers without writing
an actual file.</p>

<p style="margin-left:11%; margin-top: 1em">Some examples
follow.</p>

<p style="margin-left:11%; margin-top: 1em"># Write the MD5
hash of the encoded AVI file to the file output.avi.md5.
<br>
ffmpeg -i input.flv -f avi -y md5:output.avi.md5 <br>
# Write the MD5 hash of the encoded AVI file to stdout. <br>
ffmpeg -i input.flv -f avi -y md5:</p>

<p style="margin-left:11%; margin-top: 1em">Note that some
formats (typically <small>MOV</small> ) require the output
protocol to be seekable, so they will fail with the
<small>MD5</small> output protocol.</p>

<p style="margin-left:11%; margin-top: 1em"><b>pipe</b>
<small><br>
UNIX</small> pipe access protocol.</p>

<p style="margin-left:11%; margin-top: 1em">Read and write
from <small>UNIX</small> pipes.</p>

<p style="margin-left:11%; margin-top: 1em">The accepted
syntax is:</p>


<p style="margin-left:11%; margin-top: 1em">pipe:[&lt;number&gt;]</p>

<p style="margin-left:11%; margin-top: 1em"><i>number</i>
is the number corresponding to the file descriptor of the
pipe (e.g. 0 for stdin, 1 for stdout, 2 for stderr). If
<i>number</i> is not specified, by default the stdout file
descriptor will be used for writing, stdin for reading.</p>

<p style="margin-left:11%; margin-top: 1em">For example to
read from stdin with <b>ffmpeg</b>:</p>

<p style="margin-left:11%; margin-top: 1em">cat test.wav |
ffmpeg -i pipe:0 <br>
# ...this is the same as... <br>
cat test.wav | ffmpeg -i pipe:</p>

<p style="margin-left:11%; margin-top: 1em">For writing to
stdout with <b>ffmpeg</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -i
test.wav -f avi pipe:1 | cat &gt; test.avi <br>
# ...this is the same as... <br>
ffmpeg -i test.wav -f avi pipe: | cat &gt; test.avi</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options: <b><br>
blocksize</b></p>

<p style="margin-left:17%;">Set I/O operation maximum block
size, in bytes. Default value is &quot;INT_MAX&quot;, which
results in not limiting the requested block size. Setting
this value reasonably low improves user termination request
reaction time, which is valuable if data transmission is
slow.</p>

<p style="margin-left:11%; margin-top: 1em">Note that some
formats (typically <small>MOV</small> ), require the output
protocol to be seekable, so they will fail with the pipe
output protocol.</p>

<p style="margin-left:11%; margin-top: 1em"><b>prompeg</b>
<br>
Pro-MPEG Code of Practice #3 Release 2 <small>FEC</small>
protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The Pro-MPEG
CoP#3 <small>FEC</small> is a 2D parity-check forward error
correction mechanism for <small>MPEG-2</small> Transport
Streams sent over <small>RTP.</small></p>

<p style="margin-left:11%; margin-top: 1em">This protocol
must be used in conjunction with the &quot;rtp_mpegts&quot;
muxer and the &quot;rtp&quot; protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax is:</p>

<p style="margin-left:11%; margin-top: 1em">-f rtp_mpegts
-fec prompeg=&lt;option&gt;=&lt;val&gt;...
rtp://&lt;hostname&gt;:&lt;port&gt;</p>

<p style="margin-left:11%; margin-top: 1em">The destination
<small>UDP</small> ports are &quot;port + 2&quot; for the
column <small>FEC</small> stream and &quot;port + 4&quot;
for the row <small>FEC</small> stream.</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>l=</b><i>n</i></p></td>
<td width="2%"></td>
<td width="61%">


<p>The number of columns (4-20, LxD &lt;= 100)</p></td>
<td width="22%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>d=</b><i>n</i></p></td>
<td width="2%"></td>
<td width="61%">


<p>The number of rows (4-20, LxD &lt;= 100)</p></td>
<td width="22%">
</td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Example
usage:</p>

<p style="margin-left:11%; margin-top: 1em">-f rtp_mpegts
-fec prompeg=l=8:d=4 rtp://&lt;hostname&gt;:&lt;port&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>rtmp</b>
<br>
Real-Time Messaging Protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The Real-Time
Messaging Protocol ( <small>RTMP</small> ) is used for
streaming multimedia content across a <small>TCP/IP</small>
network.</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax is:</p>


<p style="margin-left:11%; margin-top: 1em">rtmp://[&lt;username&gt;:&lt;password&gt;@]&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;instance&gt;][/&lt;playpath&gt;]</p>

<p style="margin-left:11%; margin-top: 1em">The accepted
parameters are: <b><br>
username</b></p>

<p style="margin-left:17%;">An optional username (mostly
for publishing).</p>

<p style="margin-left:11%;"><b>password</b></p>

<p style="margin-left:17%;">An optional password (mostly
for publishing).</p>

<p style="margin-left:11%;"><b>server</b></p>

<p style="margin-left:17%;">The address of the
<small>RTMP</small> server.</p>

<p style="margin-left:11%;"><b>port</b></p>

<p style="margin-left:17%;">The number of the
<small>TCP</small> port to use (by default is 1935).</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>app</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>It is the name of the application to access. It usually
corresponds to the path where the application is installed
on the <small>RTMP</small> server (e.g. <i>/ondemand/</i>,
<i>/flash/live/</i>, etc.). You can override the value
parsed from the <small>URI</small> through the
&quot;rtmp_app&quot; option, too.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>playpath</b></p>

<p style="margin-left:17%;">It is the path or name of the
resource to play with reference to the application specified
in <i>app</i>, may be prefixed by &quot;mp4:&quot;. You can
override the value parsed from the <small>URI</small>
through the &quot;rtmp_playpath&quot; option, too.</p>

<p style="margin-left:11%;"><b>listen</b></p>

<p style="margin-left:17%;">Act as a server, listening for
an incoming connection.</p>

<p style="margin-left:11%;"><b>timeout</b></p>

<p style="margin-left:17%;">Maximum time to wait for the
incoming connection. Implies listen.</p>

<p style="margin-left:11%; margin-top: 1em">Additionally,
the following parameters can be set via command line options
(or in code via &quot;AVOption&quot;s): <b><br>
rtmp_app</b></p>

<p style="margin-left:17%;">Name of application to connect
on the <small>RTMP</small> server. This option overrides the
parameter specified in the <small>URI.</small></p>

<p style="margin-left:11%;"><b>rtmp_buffer</b></p>

<p style="margin-left:17%;">Set the client buffer time in
milliseconds. The default is 3000.</p>

<p style="margin-left:11%;"><b>rtmp_conn</b></p>

<p style="margin-left:17%;">Extra arbitrary
<small>AMF</small> connection parameters, parsed from a
string, e.g. like &quot;B:1 S:authMe O:1 NN:code:1.23
NS:flag:ok O:0&quot;. Each value is prefixed by a single
character denoting the type, B for Boolean, N for number, S
for string, O for object, or Z for null, followed by a
colon. For Booleans the data must be either 0 or 1 for
<small>FALSE</small> or <small>TRUE,</small> respectively.
Likewise for Objects the data must be 0 or 1 to end or begin
an object, respectively. Data items in subobjects may be
named, by prefixing the type with &rsquo;N&rsquo; and
specifying the name before the value (i.e.
&quot;NB:myFlag:1&quot;). This option may be used multiple
times to construct arbitrary <small>AMF</small>
sequences.</p>

<p style="margin-left:11%;"><b>rtmp_flashver</b></p>

<p style="margin-left:17%;">Version of the Flash plugin
used to run the <small>SWF</small> player. The default is
<small>LNX 9,0,124,2.</small> (When publishing, the default
is <small>FMLE/3.0</small> (compatible; &lt;libavformat
version&gt;).)</p>

<p style="margin-left:11%;"><b>rtmp_flush_interval</b></p>

<p style="margin-left:17%;">Number of packets flushed in
the same request ( <small>RTMPT</small> only). The default
is 10.</p>

<p style="margin-left:11%;"><b>rtmp_live</b></p>

<p style="margin-left:17%;">Specify that the media is a
live stream. No resuming or seeking in live streams is
possible. The default value is &quot;any&quot;, which means
the subscriber first tries to play the live stream specified
in the playpath. If a live stream of that name is not found,
it plays the recorded stream. The other possible values are
&quot;live&quot; and &quot;recorded&quot;.</p>

<p style="margin-left:11%;"><b>rtmp_pageurl</b></p>

<p style="margin-left:17%;"><small>URL</small> of the web
page in which the media was embedded. By default no value
will be sent.</p>

<p style="margin-left:11%;"><b>rtmp_playpath</b></p>

<p style="margin-left:17%;">Stream identifier to play or to
publish. This option overrides the parameter specified in
the <small>URI.</small></p>

<p style="margin-left:11%;"><b>rtmp_subscribe</b></p>

<p style="margin-left:17%;">Name of live stream to
subscribe to. By default no value will be sent. It is only
sent if the option is specified or if rtmp_live is set to
live.</p>

<p style="margin-left:11%;"><b>rtmp_swfhash</b></p>

<p style="margin-left:17%;"><small>SHA256</small> hash of
the decompressed <small>SWF</small> file (32 bytes).</p>

<p style="margin-left:11%;"><b>rtmp_swfsize</b></p>

<p style="margin-left:17%;">Size of the decompressed
<small>SWF</small> file, required for SWFVerification.</p>

<p style="margin-left:11%;"><b>rtmp_swfurl</b></p>

<p style="margin-left:17%;"><small>URL</small> of the
<small>SWF</small> player for the media. By default no value
will be sent.</p>

<p style="margin-left:11%;"><b>rtmp_swfverify</b></p>

<p style="margin-left:17%;"><small>URL</small> to player
swf file, compute hash/size automatically.</p>

<p style="margin-left:11%;"><b>rtmp_tcurl</b></p>

<p style="margin-left:17%;"><small>URL</small> of the
target stream. Defaults to proto://host[:port]/app.</p>

<p style="margin-left:11%; margin-top: 1em">For example to
read with <b>ffplay</b> a multimedia resource named
&quot;sample&quot; from the application &quot;vod&quot; from
an <small>RTMP</small> server &quot;myserver&quot;:</p>

<p style="margin-left:11%; margin-top: 1em">ffplay
rtmp://myserver/vod/sample</p>

<p style="margin-left:11%; margin-top: 1em">To publish to a
password protected server, passing the playpath and app
names separately:</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -re -i
&lt;input&gt; -f flv -rtmp_playpath some/long/path -rtmp_app
long/app/name rtmp://username:password@myserver/</p>

<p style="margin-left:11%; margin-top: 1em"><b>rtmpe</b>
<br>
Encrypted Real-Time Messaging Protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The Encrypted
Real-Time Messaging Protocol ( <small>RTMPE</small> ) is
used for streaming multimedia content within standard
cryptographic primitives, consisting of Diffie-Hellman key
exchange and <small>HMACSHA256,</small> generating a pair of
<small>RC4</small> keys.</p>

<p style="margin-left:11%; margin-top: 1em"><b>rtmps</b>
<br>
Real-Time Messaging Protocol over a secure
<small>SSL</small> connection.</p>

<p style="margin-left:11%; margin-top: 1em">The Real-Time
Messaging Protocol ( <small>RTMPS</small> ) is used for
streaming multimedia content across an encrypted
connection.</p>

<p style="margin-left:11%; margin-top: 1em"><b>rtmpt</b>
<br>
Real-Time Messaging Protocol tunneled through
<small>HTTP.</small></p>

<p style="margin-left:11%; margin-top: 1em">The Real-Time
Messaging Protocol tunneled through <small>HTTP</small> (
<small>RTMPT</small> ) is used for streaming multimedia
content within <small>HTTP</small> requests to traverse
firewalls.</p>

<p style="margin-left:11%; margin-top: 1em"><b>rtmpte</b>
<br>
Encrypted Real-Time Messaging Protocol tunneled through
<small>HTTP.</small></p>

<p style="margin-left:11%; margin-top: 1em">The Encrypted
Real-Time Messaging Protocol tunneled through
<small>HTTP</small> ( <small>RTMPTE</small> ) is used for
streaming multimedia content within <small>HTTP</small>
requests to traverse firewalls.</p>

<p style="margin-left:11%; margin-top: 1em"><b>rtmpts</b>
<br>
Real-Time Messaging Protocol tunneled through
<small>HTTPS.</small></p>

<p style="margin-left:11%; margin-top: 1em">The Real-Time
Messaging Protocol tunneled through <small>HTTPS</small> (
<small>RTMPTS</small> ) is used for streaming multimedia
content within <small>HTTPS</small> requests to traverse
firewalls.</p>


<p style="margin-left:11%; margin-top: 1em"><b>libsmbclient</b>
<br>
libsmbclient permits one to manipulate
<small>CIFS/SMB</small> network resources.</p>

<p style="margin-left:11%; margin-top: 1em">Following
syntax is required.</p>


<p style="margin-left:11%; margin-top: 1em">smb://[[domain:]user[:password@]]server[/share[/path[/file]]]</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options. <b><br>
timeout</b></p>

<p style="margin-left:17%;">Set timeout in milliseconds of
socket I/O operations used by the underlying low level
operation. By default it is set to -1, which means that the
timeout is not specified.</p>

<p style="margin-left:11%;"><b>truncate</b></p>

<p style="margin-left:17%;">Truncate existing files on
write, if set to 1. A value of 0 prevents truncating.
Default value is 1.</p>

<p style="margin-left:11%;"><b>workgroup</b></p>

<p style="margin-left:17%;">Set the workgroup used for
making connections. By default workgroup is not
specified.</p>

<p style="margin-left:11%; margin-top: 1em">For more
information see: &lt;<b>http://www.samba.org/</b>&gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>libssh</b>
<br>
Secure File Transfer Protocol via libssh</p>

<p style="margin-left:11%; margin-top: 1em">Read from or
write to remote resources using <small>SFTP</small>
protocol.</p>

<p style="margin-left:11%; margin-top: 1em">Following
syntax is required.</p>


<p style="margin-left:11%; margin-top: 1em">sftp://[user[:password]@]server[:port]/path/to/remote/resource.mpeg</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options. <b><br>
timeout</b></p>

<p style="margin-left:17%;">Set timeout of socket I/O
operations used by the underlying low level operation. By
default it is set to -1, which means that the timeout is not
specified.</p>

<p style="margin-left:11%;"><b>truncate</b></p>

<p style="margin-left:17%;">Truncate existing files on
write, if set to 1. A value of 0 prevents truncating.
Default value is 1.</p>

<p style="margin-left:11%;"><b>private_key</b></p>

<p style="margin-left:17%;">Specify the path of the file
containing private key to use during authorization. By
default libssh searches for keys in the <i>~/.ssh/</i>
directory.</p>

<p style="margin-left:11%; margin-top: 1em">Example: Play a
file stored on remote server.</p>

<p style="margin-left:11%; margin-top: 1em">ffplay
sftp://user:password@server_address:22/home/user/resource.mpeg</p>

<p style="margin-left:11%; margin-top: 1em"><b>librtmp
rtmp, rtmpe, rtmps, rtmpt, rtmpte</b> <br>
Real-Time Messaging Protocol and its variants supported
through librtmp.</p>

<p style="margin-left:11%; margin-top: 1em">Requires the
presence of the librtmp headers and library during
configuration. You need to explicitly configure the build
with &quot;--enable-librtmp&quot;. If enabled this will
replace the native <small>RTMP</small> protocol.</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
provides most client functions and a few server functions
needed to support <small>RTMP, RTMP</small> tunneled in
<small>HTTP</small> ( <small>RTMPT</small> ), encrypted
<small>RTMP</small> ( <small>RTMPE</small> ),
<small>RTMP</small> over <small>SSL/TLS</small> (
<small>RTMPS</small> ) and tunneled variants of these
encrypted types ( <small>RTMPTE, RTMPTS</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax is:</p>


<p style="margin-left:11%; margin-top: 1em">&lt;rtmp_proto&gt;://&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;playpath&gt;]
&lt;options&gt;</p>

<p style="margin-left:11%; margin-top: 1em">where
<i>rtmp_proto</i> is one of the strings &quot;rtmp&quot;,
&quot;rtmpt&quot;, &quot;rtmpe&quot;, &quot;rtmps&quot;,
&quot;rtmpte&quot;, &quot;rtmpts&quot; corresponding to each
<small>RTMP</small> variant, and <i>server</i>, <i>port</i>,
<i>app</i> and <i>playpath</i> have the same meaning as
specified for the <small>RTMP</small> native protocol.
<i>options</i> contains a list of space-separated options of
the form <i>key</i>=<i>val</i>.</p>

<p style="margin-left:11%; margin-top: 1em">See the librtmp
manual page (man 3 librtmp) for more information.</p>

<p style="margin-left:11%; margin-top: 1em">For example, to
stream a file in real-time to an <small>RTMP</small> server
using <b>ffmpeg</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -re -i
myfile -f flv rtmp://myserver/live/mystream</p>

<p style="margin-left:11%; margin-top: 1em">To play the
same stream using <b>ffplay</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ffplay
&quot;rtmp://myserver/live/mystream live=1&quot;</p>

<p style="margin-left:11%; margin-top: 1em"><b>rtp</b> <br>
Real-time Transport Protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax for an <small>RTP URL</small> is:
rtp://<i>hostname</i>[:<i>port</i>][?<i>option</i>=<i>val</i>...]</p>

<p style="margin-left:11%; margin-top: 1em"><i>port</i>
specifies the <small>RTP</small> port to use.</p>

<p style="margin-left:11%; margin-top: 1em">The following
<small>URL</small> options are supported: <b><br>
ttl=</b><i>n</i></p>

<p style="margin-left:17%;">Set the <small>TTL</small>
(Time-To-Live) value (for multicast only).</p>

<p style="margin-left:11%;"><b>rtcpport=</b><i>n</i></p>

<p style="margin-left:17%;">Set the remote
<small>RTCP</small> port to <i>n</i>.</p>


<p style="margin-left:11%;"><b>localrtpport=</b><i>n</i></p>

<p style="margin-left:17%;">Set the local
<small>RTP</small> port to <i>n</i>.</p>


<p style="margin-left:11%;"><b>localrtcpport=</b><i>n</i><b>&rsquo;</b></p>

<p style="margin-left:17%;">Set the local
<small>RTCP</small> port to <i>n</i>.</p>

<p style="margin-left:11%;"><b>pkt_size=</b><i>n</i></p>

<p style="margin-left:17%;">Set max packet size (in bytes)
to <i>n</i>.</p>

<p style="margin-left:11%;"><b>connect=0|1</b></p>

<p style="margin-left:17%;">Do a &quot;connect()&quot; on
the <small>UDP</small> socket (if set to 1) or not (if set
to 0).</p>


<p style="margin-left:11%;"><b>sources=</b><i>ip</i><b>[,</b><i>ip</i><b>]</b></p>

<p style="margin-left:17%;">List allowed source
<small>IP</small> addresses.</p>


<p style="margin-left:11%;"><b>block=</b><i>ip</i><b>[,</b><i>ip</i><b>]</b></p>

<p style="margin-left:17%;">List disallowed (blocked)
source <small>IP</small> addresses.</p>

<p style="margin-left:11%;"><b>write_to_source=0|1</b></p>

<p style="margin-left:17%;">Send packets to the source
address of the latest received packet (if set to 1) or to a
default remote address (if set to 0).</p>

<p style="margin-left:11%;"><b>localport=</b><i>n</i></p>

<p style="margin-left:17%;">Set the local
<small>RTP</small> port to <i>n</i>.</p>

<p style="margin-left:17%; margin-top: 1em">This is a
deprecated option. Instead, <b>localrtpport</b> should be
used.</p>

<p style="margin-left:11%; margin-top: 1em">Important
notes:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>1.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If <b>rtcpport</b> is not set the <small>RTCP</small>
port will be set to the <small>RTP</small> port value plus
1.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If <b>localrtpport</b> (the local <small>RTP</small>
port) is not set any available port will be used for the
local <small>RTP</small> and <small>RTCP</small> ports.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>If <b>localrtcpport</b> (the local <small>RTCP</small>
port) is not set it will be set to the local
<small>RTP</small> port value plus 1.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>rtsp</b>
<br>
Real-Time Streaming Protocol.</p>


<p style="margin-left:11%; margin-top: 1em"><small>RTSP</small>
is not technically a protocol handler in libavformat, it is
a demuxer and muxer. The demuxer supports both normal
<small>RTSP</small> (with data transferred over
<small>RTP</small> ; this is used by e.g. Apple and
Microsoft) and Real-RTSP (with data transferred over
<small>RDT</small> ).</p>

<p style="margin-left:11%; margin-top: 1em">The muxer can
be used to send a stream using <small>RTSP ANNOUNCE</small>
to a server supporting it (currently Darwin Streaming Server
and Mischa Spiegelmock&rsquo;s
&lt;<b>https://github.com/revmischa/rtsp-server</b>&gt;).</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax for a <small>RTSP</small> url is:</p>


<p style="margin-left:11%; margin-top: 1em">rtsp://&lt;hostname&gt;[:&lt;port&gt;]/&lt;path&gt;</p>

<p style="margin-left:11%; margin-top: 1em">Options can be
set on the <b>ffmpeg</b>/<b>ffplay</b> command line, or set
in code via &quot;AVOption&quot;s or in
&quot;avformat_open_input&quot;.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options are supported. <b><br>
initial_pause</b></p>

<p style="margin-left:17%;">Do not start playing the stream
immediately if set to 1. Default value is 0.</p>

<p style="margin-left:11%;"><b>rtsp_transport</b></p>

<p style="margin-left:17%;">Set <small>RTSP</small>
transport protocols.</p>

<p style="margin-left:17%; margin-top: 1em">It accepts the
following values:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p><b>udp</b></p></td>
<td width="1%"></td>
<td width="77%">


<p>Use <small>UDP</small> as lower transport protocol.</p></td></tr>
<tr valign="top" align="left">
<td width="17%"></td>
<td width="5%">


<p><b>tcp</b></p></td>
<td width="1%"></td>
<td width="77%">


<p>Use <small>TCP</small> (interleaving within the
<small>RTSP</small> control channel) as lower transport
protocol.</p> </td></tr>
</table>

<p style="margin-left:17%;"><b>udp_multicast</b></p>

<p style="margin-left:23%;">Use <small>UDP</small>
multicast as lower transport protocol.</p>

<p style="margin-left:17%;"><b>http</b></p>

<p style="margin-left:23%;">Use <small>HTTP</small>
tunneling as lower transport protocol, which is useful for
passing proxies.</p>

<p style="margin-left:17%; margin-top: 1em">Multiple lower
transport protocols may be specified, in that case they are
tried one at a time (if the setup of one fails, the next one
is tried). For the muxer, only the <b>tcp</b> and <b>udp</b>
options are supported.</p>

<p style="margin-left:11%;"><b>rtsp_flags</b></p>

<p style="margin-left:17%;">Set <small>RTSP</small>
flags.</p>

<p style="margin-left:17%; margin-top: 1em">The following
values are accepted: <b><br>
filter_src</b></p>

<p style="margin-left:23%;">Accept packets only from
negotiated peer address and port.</p>

<p style="margin-left:17%;"><b>listen</b></p>

<p style="margin-left:23%;">Act as a server, listening for
an incoming connection.</p>

<p style="margin-left:17%;"><b>prefer_tcp</b></p>

<p style="margin-left:23%;">Try <small>TCP</small> for
<small>RTP</small> transport first, if <small>TCP</small> is
available as <small>RTSP RTP</small> transport.</p>

<p style="margin-left:17%; margin-top: 1em">Default value
is <b>none</b>.</p>

<p style="margin-left:11%;"><b>allowed_media_types</b></p>

<p style="margin-left:17%;">Set media types to accept from
the server.</p>

<p style="margin-left:17%; margin-top: 1em">The following
flags are accepted: <b><br>
video <br>
audio <br>
data</b></p>

<p style="margin-left:17%; margin-top: 1em">By default it
accepts all media types.</p>

<p style="margin-left:11%;"><b>min_port</b></p>

<p style="margin-left:17%;">Set minimum local
<small>UDP</small> port. Default value is 5000.</p>

<p style="margin-left:11%;"><b>max_port</b></p>

<p style="margin-left:17%;">Set maximum local
<small>UDP</small> port. Default value is 65000.</p>

<p style="margin-left:11%;"><b>timeout</b></p>

<p style="margin-left:17%;">Set maximum timeout (in
seconds) to wait for incoming connections.</p>

<p style="margin-left:17%; margin-top: 1em">A value of -1
means infinite (default). This option implies the
<b>rtsp_flags</b> set to <b>listen</b>.</p>

<p style="margin-left:11%;"><b>reorder_queue_size</b></p>

<p style="margin-left:17%;">Set number of packets to buffer
for handling of reordered packets.</p>

<p style="margin-left:11%;"><b>stimeout</b></p>

<p style="margin-left:17%;">Set socket <small>TCP
I/O</small> timeout in microseconds.</p>

<p style="margin-left:11%;"><b>user-agent</b></p>

<p style="margin-left:17%;">Override User-Agent header. If
not specified, it defaults to the libavformat identifier
string.</p>

<p style="margin-left:11%; margin-top: 1em">When receiving
data over <small>UDP,</small> the demuxer tries to reorder
received packets (since they may arrive out of order, or
packets may get lost totally). This can be disabled by
setting the maximum demuxing delay to zero (via the
&quot;max_delay&quot; field of AVFormatContext).</p>

<p style="margin-left:11%; margin-top: 1em">When watching
multi-bitrate Real-RTSP streams with <b>ffplay</b>, the
streams to display can be chosen with &quot;-vst&quot;
<i>n</i> and &quot;-ast&quot; <i>n</i> for video and audio
respectively, and can be switched on the fly by pressing
&quot;v&quot; and &quot;a&quot;.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<p style="margin-left:11%; margin-top: 1em">The following
examples all make use of the <b>ffplay</b> and <b>ffmpeg</b>
tools.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p>Watch a stream over <small>UDP,</small> with a max
reordering delay of 0.5 seconds:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">ffplay
-max_delay 500000 -rtsp_transport udp
rtsp://server/video.mp4</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="52%">


<p style="margin-top: 1em">Watch a stream tunneled over
<small>HTTP:</small></p> </td>
<td width="31%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">ffplay
-rtsp_transport http rtsp://server/video.mp4</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Send a stream in realtime to a
<small>RTSP</small> server, for others to watch:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">ffmpeg -re -i
&lt;input&gt; -f rtsp -muxdelay 0.1
rtsp://server/live.sdp</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="45%">


<p style="margin-top: 1em">Receive a stream in
realtime:</p> </td>
<td width="38%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">ffmpeg
-rtsp_flags listen -i rtsp://ownaddress/live.sdp
&lt;output&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>sap</b> <br>
Session Announcement Protocol ( <small>RFC 2974</small> ).
This is not technically a protocol handler in libavformat,
it is a muxer and demuxer. It is used for signalling of
<small>RTP</small> streams, by announcing the
<small>SDP</small> for the streams regularly on a separate
port.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Muxer</i></p>

<p style="margin-left:11%; margin-top: 1em">The syntax for
a <small>SAP</small> url given to the muxer is:</p>


<p style="margin-left:11%; margin-top: 1em">sap://&lt;destination&gt;[:&lt;port&gt;][?&lt;options&gt;]</p>

<p style="margin-left:11%; margin-top: 1em">The
<small>RTP</small> packets are sent to <i>destination</i> on
port <i>port</i>, or to port 5004 if no port is specified.
<i>options</i> is a &quot;&amp;&quot;-separated list. The
following options are supported: <b><br>
announce_addr=</b><i>address</i></p>

<p style="margin-left:17%;">Specify the destination
<small>IP</small> address for sending the announcements to.
If omitted, the announcements are sent to the commonly used
<small>SAP</small> announcement multicast address
224.2.127.254 (sap.mcast.net), or ff0e::2:7ffe if
<i>destination</i> is an IPv6 address.</p>


<p style="margin-left:11%;"><b>announce_port=</b><i>port</i></p>

<p style="margin-left:17%;">Specify the port to send the
announcements on, defaults to 9875 if not specified.</p>

<p style="margin-left:11%;"><b>ttl=</b><i>ttl</i></p>

<p style="margin-left:17%;">Specify the time to live value
for the announcements and <small>RTP</small> packets,
defaults to 255.</p>


<p style="margin-left:11%;"><b>same_port=</b><i>0|1</i></p>

<p style="margin-left:17%;">If set to 1, send all
<small>RTP</small> streams on the same port pair. If zero
(the default), all streams are sent on unique ports, with
each stream on a port 2 numbers higher than the previous.
VLC/Live555 requires this to be set to 1, to be able to
receive the stream. The <small>RTP</small> stack in
libavformat for receiving requires all streams to be sent on
unique ports.</p>

<p style="margin-left:11%; margin-top: 1em">Example command
lines follow.</p>

<p style="margin-left:11%; margin-top: 1em">To broadcast a
stream on the local subnet, for watching in
<small>VLC:</small></p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -re -i
&lt;input&gt; -f sap sap://224.0.0.255?same_port=1</p>

<p style="margin-left:11%; margin-top: 1em">Similarly, for
watching in <b>ffplay</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -re -i
&lt;input&gt; -f sap sap://224.0.0.255</p>

<p style="margin-left:11%; margin-top: 1em">And for
watching in <b>ffplay</b>, over IPv6:</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -re -i
&lt;input&gt; -f sap sap://[ff0e::1:2:3:4]</p>


<p style="margin-left:11%; margin-top: 1em"><i>Demuxer</i></p>

<p style="margin-left:11%; margin-top: 1em">The syntax for
a <small>SAP</small> url given to the demuxer is:</p>


<p style="margin-left:11%; margin-top: 1em">sap://[&lt;address&gt;][:&lt;port&gt;]</p>

<p style="margin-left:11%; margin-top: 1em"><i>address</i>
is the multicast address to listen for announcements on, if
omitted, the default 224.2.127.254 (sap.mcast.net) is used.
<i>port</i> is the port that is listened on, 9875 if
omitted.</p>

<p style="margin-left:11%; margin-top: 1em">The demuxers
listens for announcements on the given address and port.
Once an announcement is received, it tries to receive that
particular stream.</p>

<p style="margin-left:11%; margin-top: 1em">Example command
lines follow.</p>

<p style="margin-left:11%; margin-top: 1em">To play back
the first stream announced on the normal <small>SAP</small>
multicast address:</p>

<p style="margin-left:11%; margin-top: 1em">ffplay
sap://</p>

<p style="margin-left:11%; margin-top: 1em">To play back
the first stream announced on one the default IPv6
<small>SAP</small> multicast address:</p>

<p style="margin-left:11%; margin-top: 1em">ffplay
sap://[ff0e::2:7ffe]</p>

<p style="margin-left:11%; margin-top: 1em"><b>sctp</b>
<br>
Stream Control Transmission Protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The accepted
<small>URL</small> syntax is:</p>


<p style="margin-left:11%; margin-top: 1em">sctp://&lt;host&gt;:&lt;port&gt;[?&lt;options&gt;]</p>

<p style="margin-left:11%; margin-top: 1em">The protocol
accepts the following options: <b><br>
listen</b></p>

<p style="margin-left:17%;">If set to any value, listen for
an incoming connection. Outgoing connection is done by
default.</p>

<p style="margin-left:11%;"><b>max_streams</b></p>

<p style="margin-left:17%;">Set the maximum number of
streams. By default no limit is set.</p>

<p style="margin-left:11%; margin-top: 1em"><b>srt</b> <br>
Haivision Secure Reliable Transport Protocol via libsrt.</p>

<p style="margin-left:11%; margin-top: 1em">The supported
syntax for a <small>SRT URL</small> is:</p>


<p style="margin-left:11%; margin-top: 1em">srt://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]</p>

<p style="margin-left:11%; margin-top: 1em"><i>options</i>
contains a list of &amp;-separated options of the form
<i>key</i>=<i>val</i>.</p>

<p style="margin-left:11%; margin-top: 1em">or</p>


<p style="margin-left:11%; margin-top: 1em">&lt;options&gt;
srt://&lt;hostname&gt;:&lt;port&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><i>options</i>
contains a list of &rsquo;-<i>key val</i>&rsquo;
options.</p>

<p style="margin-left:11%; margin-top: 1em">This protocol
accepts the following options. <b><br>
connect_timeout</b></p>

<p style="margin-left:17%;">Connection timeout;
<small>SRT</small> cannot connect for <small>RTT</small>
&gt; 1500 msec (2 handshake exchanges) with the default
connect timeout of 3 seconds. This option applies to the
caller and rendezvous connection modes. The connect timeout
is 10 times the value set for the rendezvous mode (which can
be used as a workaround for this connection problem with
earlier versions).</p>

<p style="margin-left:11%;"><b>ffs=</b><i>bytes</i></p>

<p style="margin-left:17%;">Flight Flag Size (Window Size),
in bytes. <small>FFS</small> is actually an internal
parameter and you should set it to not less than
<b>recv_buffer_size</b> and <b>mss</b>. The default value is
relatively large, therefore unless you set a very large
receiver buffer, you do not need to change this option.
Default value is 25600.</p>


<p style="margin-left:11%;"><b>inputbw=</b><i>bytes/seconds</i></p>

<p style="margin-left:17%;">Sender nominal input rate, in
bytes per seconds. Used along with <b>oheadbw</b>, when
<b>maxbw</b> is set to relative (0), to calculate maximum
sending rate when recovery packets are sent along with the
main media stream: <b>inputbw</b> * (100 + <b>oheadbw</b>) /
100 if <b>inputbw</b> is not set while <b>maxbw</b> is set
to relative (0), the actual input rate is evaluated inside
the library. Default value is 0.</p>

<p style="margin-left:11%;"><b>iptos=</b><i>tos</i></p>

<p style="margin-left:17%;"><small>IP</small> Type of
Service. Applies to sender only. Default value is 0xB8.</p>

<p style="margin-left:11%;"><b>ipttl=</b><i>ttl</i></p>

<p style="margin-left:17%;"><small>IP</small> Time To Live.
Applies to sender only. Default value is 64.</p>

<p style="margin-left:11%;"><b>latency</b></p>

<p style="margin-left:17%;">Timestamp-based Packet Delivery
Delay. Used to absorb bursts of missed packet
retransmissions. This flag sets both <b>rcvlatency</b> and
<b>peerlatency</b> to the same value. Note that prior to
version 1.3.0 this is the only flag to set the latency,
however this is effectively equivalent to setting
<b>peerlatency</b>, when side is sender and
<b>rcvlatency</b> when side is receiver, and the
bidirectional stream sending is not supported.</p>

<p style="margin-left:11%;"><b>listen_timeout</b></p>

<p style="margin-left:17%;">Set socket listen timeout.</p>


<p style="margin-left:11%;"><b>maxbw=</b><i>bytes/seconds</i></p>

<p style="margin-left:17%;">Maximum sending bandwidth, in
bytes per seconds. -1 infinite ( <small>CSRTCC</small> limit
is 30mbps) 0 relative to input rate (see <b>inputbw</b>)
&gt;0 absolute limit value Default value is 0 (relative)</p>


<p style="margin-left:11%;"><b>mode=</b><i>caller|listener|rendezvous</i></p>

<p style="margin-left:17%;">Connection mode. <b>caller</b>
opens client connection. <b>listener</b> starts server to
listen for incoming connections. <b>rendezvous</b> use
Rendez-Vous connection mode. Default value is caller.</p>

<p style="margin-left:11%;"><b>mss=</b><i>bytes</i></p>

<p style="margin-left:17%;">Maximum Segment Size, in bytes.
Used for buffer allocation and rate calculation using a
packet counter assuming fully filled packets. The smallest
<small>MSS</small> between the peers is used. This is 1500
by default in the overall internet. This is the maximum size
of the <small>UDP</small> packet and can be only decreased,
unless you have some unusual dedicated network settings.
Default value is 1500.</p>


<p style="margin-left:11%;"><b>nakreport=</b><i>1|0</i></p>

<p style="margin-left:17%;">If set to 1, Receiver will send
&rsquo;UMSG_LOSSREPORT&rsquo; messages periodically until a
lost packet is retransmitted or intentionally dropped.
Default value is 1.</p>


<p style="margin-left:11%;"><b>oheadbw=</b><i>percents</i></p>

<p style="margin-left:17%;">Recovery bandwidth overhead
above input rate, in percents. See <b>inputbw</b>. Default
value is 25%.</p>


<p style="margin-left:11%;"><b>passphrase=</b><i>string</i></p>

<p style="margin-left:17%;">HaiCrypt Encryption/Decryption
Passphrase string, length from 10 to 79 characters. The
passphrase is the shared secret between the sender and the
receiver. It is used to generate the Key Encrypting Key
using <small>PBKDF2</small> (Password-Based Key Derivation
Function). It is used only if <b>pbkeylen</b> is non-zero.
It is used on the receiver only if the received data is
encrypted. The configured passphrase cannot be recovered
(write-only).</p>


<p style="margin-left:11%;"><b>payload_size=</b><i>bytes</i></p>

<p style="margin-left:17%;">Sets the maximum declared size
of a packet transferred during the single call to the
sending function in Live mode. Use 0 if this value
isn&rsquo;t used (which is default in file mode). Default is
-1 (automatic), which typically means MPEG-TS; if you are
going to use <small>SRT</small> to send any different kind
of payload, such as, for example, wrapping a live stream in
very small frames, then you can use a bigger maximum frame
size, though not greater than 1456 bytes.</p>


<p style="margin-left:11%;"><b>pkt_size=</b><i>bytes</i></p>

<p style="margin-left:17%;">Alias for
<b>payload_size</b>.</p>

<p style="margin-left:11%;"><b>peerlatency</b></p>

<p style="margin-left:17%;">The latency value (as described
in <b>rcvlatency</b>) that is set by the sender side as a
minimum value for the receiver.</p>


<p style="margin-left:11%;"><b>pbkeylen=</b><i>bytes</i></p>

<p style="margin-left:17%;">Sender encryption key length,
in bytes. Only can be set to 0, 16, 24 and 32. Enable sender
encryption if not 0. Not required on receiver (set to 0),
key size obtained from sender in HaiCrypt handshake. Default
value is 0.</p>

<p style="margin-left:11%;"><b>rcvlatency</b></p>

<p style="margin-left:17%;">The time that should elapse
since the moment when the packet was sent and the moment
when it&rsquo;s delivered to the receiver application in the
receiving function. This time should be a buffer time large
enough to cover the time spent for sending, unexpectedly
extended <small>RTT</small> time, and the time needed to
retransmit the lost <small>UDP</small> packet. The effective
latency value will be the maximum of this options&rsquo;
value and the value of <b>peerlatency</b> set by the peer
side. Before version 1.3.0 this option is only available as
<b>latency</b>.</p>


<p style="margin-left:11%;"><b>recv_buffer_size=</b><i>bytes</i></p>

<p style="margin-left:17%;">Set <small>UDP</small> receive
buffer size, expressed in bytes.</p>


<p style="margin-left:11%;"><b>send_buffer_size=</b><i>bytes</i></p>

<p style="margin-left:17%;">Set <small>UDP</small> send
buffer size, expressed in bytes.</p>

<p style="margin-left:11%;"><b>rw_timeout</b></p>

<p style="margin-left:17%;">Set raise error timeout for
read/write optations.</p>

<p style="margin-left:17%; margin-top: 1em">This option is
only relevant in read mode: if no data arrived in more than
this time interval, raise error.</p>


<p style="margin-left:11%;"><b>tlpktdrop=</b><i>1|0</i></p>

<p style="margin-left:17%;">Too-late Packet Drop. When
enabled on receiver, it skips missing packets that have not
been delivered in time and delivers the following packets to
the application when their time-to-play has come. It also
sends a fake <small>ACK</small> to the sender. When enabled
on sender and enabled on the receiving peer, the sender
drops the older packets that have no chance of being
delivered in time. It was automatically enabled in the
sender if the receiver supports it.</p>

<p style="margin-left:11%;"><b>sndbuf=</b><i>bytes</i></p>

<p style="margin-left:17%;">Set send buffer size, expressed
in bytes.</p>

<p style="margin-left:11%;"><b>rcvbuf=</b><i>bytes</i></p>

<p style="margin-left:17%;">Set receive buffer size,
expressed in bytes.</p>

<p style="margin-left:17%; margin-top: 1em">Receive buffer
must not be greater than <b>ffs</b>.</p>


<p style="margin-left:11%;"><b>lossmaxttl=</b><i>packets</i></p>

<p style="margin-left:17%;">The value up to which the
Reorder Tolerance may grow. When Reorder Tolerance is &gt;
0, then packet loss report is delayed until that number of
packets come in. Reorder Tolerance increases every time a
&quot;belated&quot; packet has come, but it wasn&rsquo;t due
to retransmission (that is, when <small>UDP</small> packets
tend to come out of order), with the difference between the
latest sequence and this packet&rsquo;s sequence, and not
more than the value of this option. By default it&rsquo;s 0,
which means that this mechanism is turned off, and the loss
report is always sent immediately upon experiencing a
&quot;gap&quot; in sequences.</p>

<p style="margin-left:11%;"><b>minversion</b></p>

<p style="margin-left:17%;">The minimum <small>SRT</small>
version that is required from the peer. A connection to a
peer that does not satisfy the minimum version requirement
will be rejected.</p>

<p style="margin-left:17%; margin-top: 1em">The version
format in hex is 0xXXYYZZ for x.y.z in human readable
form.</p>


<p style="margin-left:11%;"><b>streamid=</b><i>string</i></p>

<p style="margin-left:17%;">A string limited to 512
characters that can be set on the socket prior to
connecting. This stream <small>ID</small> will be able to be
retrieved by the listener side from the socket that is
returned from srt_accept and was connected by a socket with
that set stream <small>ID. SRT</small> does not enforce any
special interpretation of the contents of this string. This
option doesnXt make sense in Rendezvous connection; the
result might be that simply one side will override the value
from the other side and itXs the matter of luck which one
would win</p>


<p style="margin-left:11%;"><b>smoother=</b><i>live|file</i></p>

<p style="margin-left:17%;">The type of Smoother used for
the transmission for that socket, which is responsible for
the transmission and congestion control. The Smoother type
must be exactly the same on both connecting parties,
otherwise the connection is rejected.</p>


<p style="margin-left:11%;"><b>messageapi=</b><i>1|0</i></p>

<p style="margin-left:17%;">When set, this socket uses the
Message <small>API,</small> otherwise it uses Buffer
<small>API.</small> Note that in live mode (see
<b>transtype</b>) thereXs only message <small>API</small>
available. In File mode you can chose to use one of two
modes:</p>

<p style="margin-left:17%; margin-top: 1em">Stream
<small>API</small> (default, when this option is false). In
this mode you may send as many data as you wish with one
sending instruction, or even use dedicated functions that
read directly from a file. The internal facility will take
care of any speed and congestion control. When receiving,
you can also receive as many data as desired, the data not
extracted will be waiting for the next call. There is no
boundary between data portions in the Stream mode.</p>

<p style="margin-left:17%; margin-top: 1em">Message
<small>API.</small> In this mode your single sending
instruction passes exactly one piece of data that has
boundaries (a message). Contrary to Live mode, this message
may span across multiple <small>UDP</small> packets and the
only size limitation is that it shall fit as a whole in the
sending buffer. The receiver shall use as large buffer as
necessary to receive the message, otherwise the message will
not be given up. When the message is not complete (not all
packets received or there was a packet loss) it will not be
given up.</p>


<p style="margin-left:11%;"><b>transtype=</b><i>live|file</i></p>

<p style="margin-left:17%;">Sets the transmission type for
the socket, in particular, setting this option sets multiple
other parameters to their default values as required for a
particular transmission type.</p>

<p style="margin-left:17%; margin-top: 1em">live: Set
options as for live transmission. In this mode, you should
send by one sending instruction only so many data that fit
in one <small>UDP</small> packet, and limited to the value
defined first in <b>payload_size</b> (1316 is default in
this mode). There is no speed control in this mode, only the
bandwidth control, if configured, in order to not exceed the
bandwidth with the overhead transmission (retransmitted and
control packets).</p>

<p style="margin-left:17%; margin-top: 1em">file: Set
options as for non-live transmission. See <b>messageapi</b>
for further explanations</p>

<p style="margin-left:11%; margin-top: 1em">For more
information see:
&lt;<b>https://github.com/Haivision/srt</b>&gt;.</p>

<p style="margin-left:11%; margin-top: 1em"><b>srtp</b>
<br>
Secure Real-time Transport Protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The accepted
options are: <b><br>
srtp_in_suite <br>
srtp_out_suite</b></p>

<p style="margin-left:17%;">Select input and output
encoding suites.</p>

<p style="margin-left:17%; margin-top: 1em">Supported
values: <b><small><br>
AES_CM_128_HMAC_SHA1_80 <br>
SRTP_AES128_CM_HMAC_SHA1_80 <br>
AES_CM_128_HMAC_SHA1_32 <br>
SRTP_AES128_CM_HMAC_SHA1_32</small></b></p>

<p style="margin-left:11%;"><b>srtp_in_params <br>
srtp_out_params</b></p>

<p style="margin-left:17%;">Set input and output encoding
parameters, which are expressed by a base64-encoded
representation of a binary block. The first 16 bytes of this
binary block are used as master key, the following 14 bytes
are used as master salt.</p>

<p style="margin-left:11%; margin-top: 1em"><b>subfile</b>
<br>
Virtually extract a segment of a file or another stream. The
underlying stream must be seekable.</p>

<p style="margin-left:11%; margin-top: 1em">Accepted
options: <b><br>
start</b></p>

<p style="margin-left:17%;">Start offset of the extracted
segment, in bytes.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>end</b></p></td>
<td width="2%"></td>
<td width="83%">


<p>End offset of the extracted segment, in bytes. If set to
0, extract till end of file.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Examples:</p>

<p style="margin-left:11%; margin-top: 1em">Extract a
chapter from a <small>DVD VOB</small> file (start and end
sectors obtained externally and multiplied by 2048):</p>


<p style="margin-left:11%; margin-top: 1em">subfile,,start,153391104,end,268142592,,:/media/dvd/VIDEO_TS/VTS_08_1.VOB</p>

<p style="margin-left:11%; margin-top: 1em">Play an
<small>AVI</small> file directly from a <small>TAR</small>
archive:</p>


<p style="margin-left:11%; margin-top: 1em">subfile,,start,183241728,end,366490624,,:archive.tar</p>

<p style="margin-left:11%; margin-top: 1em">Play a MPEG-TS
file from start offset till end:</p>


<p style="margin-left:11%; margin-top: 1em">subfile,,start,32815239,end,0,,:video.ts</p>

<p style="margin-left:11%; margin-top: 1em"><b>tee</b> <br>
Writes the output to multiple protocols. The individual
outputs are separated by |</p>


<p style="margin-left:11%; margin-top: 1em">tee:file://path/to/local/this.avi|file://path/to/local/that.avi</p>

<p style="margin-left:11%; margin-top: 1em"><b>tcp</b> <br>
Transmission Control Protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax for a <small>TCP</small> url is:</p>


<p style="margin-left:11%; margin-top: 1em">tcp://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]</p>

<p style="margin-left:11%; margin-top: 1em"><i>options</i>
contains a list of &amp;-separated options of the form
<i>key</i>=<i>val</i>.</p>

<p style="margin-left:11%; margin-top: 1em">The list of
supported options follows. <b><br>
listen=</b><i>1|0</i></p>

<p style="margin-left:17%;">Listen for an incoming
connection. Default value is 0.</p>


<p style="margin-left:11%;"><b>timeout=</b><i>microseconds</i></p>

<p style="margin-left:17%;">Set raise error timeout,
expressed in microseconds.</p>

<p style="margin-left:17%; margin-top: 1em">This option is
only relevant in read mode: if no data arrived in more than
this time interval, raise error.</p>


<p style="margin-left:11%;"><b>listen_timeout=</b><i>milliseconds</i></p>

<p style="margin-left:17%;">Set listen timeout, expressed
in milliseconds.</p>


<p style="margin-left:11%;"><b>recv_buffer_size=</b><i>bytes</i></p>

<p style="margin-left:17%;">Set receive buffer size,
expressed bytes.</p>


<p style="margin-left:11%;"><b>send_buffer_size=</b><i>bytes</i></p>

<p style="margin-left:17%;">Set send buffer size, expressed
bytes.</p>


<p style="margin-left:11%;"><b>tcp_nodelay=</b><i>1|0</i></p>

<p style="margin-left:17%;">Set <small>TCP_NODELAY</small>
to disable Nagle&rsquo;s algorithm. Default value is 0.</p>


<p style="margin-left:11%;"><b>tcp_mss=</b><i>bytes</i></p>

<p style="margin-left:17%;">Set maximum segment size for
outgoing <small>TCP</small> packets, expressed in bytes.</p>

<p style="margin-left:11%; margin-top: 1em">The following
example shows how to setup a listening <small>TCP</small>
connection with <b>ffmpeg</b>, which is then accessed with
<b>ffplay</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -i
&lt;input&gt; -f &lt;format&gt;
tcp://&lt;hostname&gt;:&lt;port&gt;?listen <br>
ffplay tcp://&lt;hostname&gt;:&lt;port&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>tls</b> <br>
Transport Layer Security ( <small>TLS</small> ) / Secure
Sockets Layer ( <small>SSL</small> )</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax for a <small>TLS/SSL</small> url is:</p>


<p style="margin-left:11%; margin-top: 1em">tls://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]</p>

<p style="margin-left:11%; margin-top: 1em">The following
parameters can be set via command line options (or in code
via &quot;AVOption&quot;s): <b><br>
ca_file, cafile=</b><i>filename</i></p>

<p style="margin-left:17%;">A file containing certificate
authority ( <small>CA</small> ) root certificates to treat
as trusted. If the linked <small>TLS</small> library
contains a default this might not need to be specified for
verification to work, but not all libraries and setups have
defaults built in. The file must be in OpenSSL
<small>PEM</small> format.</p>


<p style="margin-left:11%;"><b>tls_verify=</b><i>1|0</i></p>

<p style="margin-left:17%;">If enabled, try to verify the
peer that we are communicating with. Note, if using OpenSSL,
this currently only makes sure that the peer certificate is
signed by one of the root certificates in the
<small>CA</small> database, but it does not validate that
the certificate actually matches the host name we are trying
to connect to. (With other backends, the host name is
validated as well.)</p>

<p style="margin-left:17%; margin-top: 1em">This is
disabled by default since it requires a <small>CA</small>
database to be provided by the caller in many cases.</p>

<p style="margin-left:11%;"><b>cert_file,
cert=</b><i>filename</i></p>

<p style="margin-left:17%;">A file containing a certificate
to use in the handshake with the peer. (When operating as
server, in listen mode, this is more often required by the
peer, while client certificates only are mandated in certain
setups.)</p>

<p style="margin-left:11%;"><b>key_file,
key=</b><i>filename</i></p>

<p style="margin-left:17%;">A file containing the private
key for the certificate.</p>

<p style="margin-left:11%;"><b>listen=</b><i>1|0</i></p>

<p style="margin-left:17%;">If enabled, listen for
connections on the provided port, and assume the server role
in the handshake instead of the client role.</p>

<p style="margin-left:11%; margin-top: 1em">Example command
lines:</p>

<p style="margin-left:11%; margin-top: 1em">To create a
<small>TLS/SSL</small> server that serves an input
stream.</p>

<p style="margin-left:11%; margin-top: 1em">ffmpeg -i
&lt;input&gt; -f &lt;format&gt;
tls://&lt;hostname&gt;:&lt;port&gt;?listen&amp;cert=&lt;server.crt&gt;&amp;key=&lt;server.key&gt;</p>

<p style="margin-left:11%; margin-top: 1em">To play back a
stream from the <small>TLS/SSL</small> server using
<b>ffplay</b>:</p>

<p style="margin-left:11%; margin-top: 1em">ffplay
tls://&lt;hostname&gt;:&lt;port&gt;</p>

<p style="margin-left:11%; margin-top: 1em"><b>udp</b> <br>
User Datagram Protocol.</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax for an <small>UDP URL</small> is:</p>


<p style="margin-left:11%; margin-top: 1em">udp://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]</p>

<p style="margin-left:11%; margin-top: 1em"><i>options</i>
contains a list of &amp;-separated options of the form
<i>key</i>=<i>val</i>.</p>

<p style="margin-left:11%; margin-top: 1em">In case
threading is enabled on the system, a circular buffer is
used to store the incoming data, which allows one to reduce
loss of data due to <small>UDP</small> socket buffer
overruns. The <i>fifo_size</i> and <i>overrun_nonfatal</i>
options are related to this buffer.</p>

<p style="margin-left:11%; margin-top: 1em">The list of
supported options follows. <b><br>
buffer_size=</b><i>size</i></p>

<p style="margin-left:17%;">Set the <small>UDP</small>
maximum socket buffer size in bytes. This is used to set
either the receive or send buffer size, depending on what
the socket is used for. Default is 64KB. See also
<i>fifo_size</i>.</p>


<p style="margin-left:11%;"><b>bitrate=</b><i>bitrate</i></p>

<p style="margin-left:17%;">If set to nonzero, the output
will have the specified constant bitrate if the input has
enough packets to sustain it.</p>


<p style="margin-left:11%;"><b>burst_bits=</b><i>bits</i></p>

<p style="margin-left:17%;">When using <i>bitrate</i> this
specifies the maximum number of bits in packet bursts.</p>


<p style="margin-left:11%;"><b>localport=</b><i>port</i></p>

<p style="margin-left:17%;">Override the local
<small>UDP</small> port to bind with.</p>


<p style="margin-left:11%;"><b>localaddr=</b><i>addr</i></p>

<p style="margin-left:17%;">Local <small>IP</small> address
of a network interface used for sending packets or joining
multicast groups.</p>


<p style="margin-left:11%;"><b>pkt_size=</b><i>size</i></p>

<p style="margin-left:17%;">Set the size in bytes of
<small>UDP</small> packets.</p>

<p style="margin-left:11%;"><b>reuse=</b><i>1|0</i></p>

<p style="margin-left:17%;">Explicitly allow or disallow
reusing <small>UDP</small> sockets.</p>

<p style="margin-left:11%;"><b>ttl=</b><i>ttl</i></p>

<p style="margin-left:17%;">Set the time to live value (for
multicast only).</p>

<p style="margin-left:11%;"><b>connect=</b><i>1|0</i></p>

<p style="margin-left:17%;">Initialize the
<small>UDP</small> socket with &quot;connect()&quot;. In
this case, the destination address can&rsquo;t be changed
with ff_udp_set_remote_url later. If the destination address
isn&rsquo;t known at the start, this option can be specified
in ff_udp_set_remote_url, too. This allows finding out the
source address for the packets with getsockname, and makes
writes return with <small>AVERROR</small> (
<small>ECONNREFUSED</small> ) if &quot;destination
unreachable&quot; is received. For receiving, this gives the
benefit of only receiving packets from the specified peer
address/port.</p>


<p style="margin-left:11%;"><b>sources=</b><i>address</i><b>[,</b><i>address</i><b>]</b></p>

<p style="margin-left:17%;">Only receive packets sent from
the specified addresses. In case of multicast, also
subscribe to multicast traffic coming from these addresses
only.</p>


<p style="margin-left:11%;"><b>block=</b><i>address</i><b>[,</b><i>address</i><b>]</b></p>

<p style="margin-left:17%;">Ignore packets sent from the
specified addresses. In case of multicast, also exclude the
source addresses in the multicast subscription.</p>


<p style="margin-left:11%;"><b>fifo_size=</b><i>units</i></p>

<p style="margin-left:17%;">Set the <small>UDP</small>
receiving circular buffer size, expressed as a number of
packets with size of 188 bytes. If not specified defaults to
7*4096.</p>


<p style="margin-left:11%;"><b>overrun_nonfatal=</b><i>1|0</i></p>

<p style="margin-left:17%;">Survive in case of
<small>UDP</small> receiving circular buffer overrun.
Default value is 0.</p>


<p style="margin-left:11%;"><b>timeout=</b><i>microseconds</i></p>

<p style="margin-left:17%;">Set raise error timeout,
expressed in microseconds.</p>

<p style="margin-left:17%; margin-top: 1em">This option is
only relevant in read mode: if no data arrived in more than
this time interval, raise error.</p>


<p style="margin-left:11%;"><b>broadcast=</b><i>1|0</i></p>

<p style="margin-left:17%;">Explicitly allow or disallow
<small>UDP</small> broadcasting.</p>

<p style="margin-left:17%; margin-top: 1em">Note that
broadcasting may not work properly on networks having a
broadcast storm protection.</p>


<p style="margin-left:11%; margin-top: 1em"><i>Examples</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="5%"></td>
<td width="78%">


<p>Use <b>ffmpeg</b> to stream over <small>UDP</small> to a
remote endpoint:</p></td>
<td width="5%">
</td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">ffmpeg -i
&lt;input&gt; -f &lt;format&gt;
udp://&lt;hostname&gt;:&lt;port&gt;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Use <b>ffmpeg</b> to stream in
mpegts format over <small>UDP</small> using 188 sized
<small>UDP</small> packets, using a large input buffer:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">ffmpeg -i
&lt;input&gt; -f mpegts
udp://&lt;hostname&gt;:&lt;port&gt;?pkt_size=188&amp;buffer_size=65535</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="5%"></td>
<td width="83%">


<p style="margin-top: 1em">Use <b>ffmpeg</b> to receive
over <small>UDP</small> from a remote endpoint:</p></td></tr>
</table>

<p style="margin-left:17%; margin-top: 1em">ffmpeg -i
udp://[&lt;multicast-address&gt;]:&lt;port&gt; ...</p>

<p style="margin-left:11%; margin-top: 1em"><b>unix</b>
<br>
Unix local socket</p>

<p style="margin-left:11%; margin-top: 1em">The required
syntax for a Unix socket <small>URL</small> is:</p>


<p style="margin-left:11%; margin-top: 1em">unix://&lt;filepath&gt;</p>

<p style="margin-left:11%; margin-top: 1em">The following
parameters can be set via command line options (or in code
via &quot;AVOption&quot;s): <b><br>
timeout</b></p>

<p style="margin-left:17%;">Timeout in ms.</p>

<p style="margin-left:11%;"><b>listen</b></p>

<p style="margin-left:17%;">Create the Unix socket in
listening mode.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>ffmpeg</b>(1),
<b>ffplay</b>(1), <b>ffprobe</b>(1),
<b>libavformat</b>(3)</p>

<h2>AUTHORS
<a name="AUTHORS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The FFmpeg
developers.</p>

<p style="margin-left:11%; margin-top: 1em">For details
about the authorship, see the Git history of the project
(git://source.ffmpeg.org/ffmpeg), e.g. by typing the command
<b>git log</b> in the FFmpeg source directory, or browsing
the online repository at
&lt;<b>http://source.ffmpeg.org</b>&gt;.</p>

<p style="margin-left:11%; margin-top: 1em">Maintainers for
the specific components are listed in the file
<i><small>MAINTAINERS</small></i> in the source code
tree.</p>
<hr>
</body>
</html>
